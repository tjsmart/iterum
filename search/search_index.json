{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Rusty iterators in Python.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install iterum\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from iterum import iterum, Some, nil, seq\nitr = iterum([1, 2])\nassert itr.next() == Some(1)\nassert itr.next() == Some(2)\nassert itr.next() == nil\nitr = iterum([1, 2, 3, 4])\nassert itr.fold(0, lambda acc, x: acc + x) == 10\nlst = (\nseq(5)\n.map(lambda x: x**2 + 1)\n.filter(lambda x: x % 2)\n.collect()\n)\nassert lst == [1, 5, 17]\n</code></pre> <p>For more examples checkout the API documentation.</p>"},{"location":"#license","title":"License","text":"<p><code>iterum</code> is distributed under the terms of the MIT license.</p>"},{"location":"api/","title":"API","text":"<p> Iterum </p> <p></p> <p> Ranges </p> <p></p> <p> Option </p> <p></p> <p> Other </p>"},{"location":"api/#iterum.iterum","title":"<code>iterum.iterum</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> <p>Implements an Iterum interface from an iterable object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2])\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3, 4])\n&gt;&gt;&gt; assert itr.fold(0, lambda acc, x: acc + x) == 10\n</code></pre> <pre><code>&gt;&gt;&gt; x = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; y = (\n...     iterum(x)\n...     .map(lambda x: x**2 + 1)\n...     .filter(lambda x: x % 2)\n...     .collect()\n... )\n&gt;&gt;&gt; assert y == [1, 5, 17]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>class iterum(Iterum[T_co]):\n\"\"\"\n    Implements an [Iterum][iterum.Iterum] interface from an iterable object.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([1, 2])\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; itr = iterum([1, 2, 3, 4])\n        &gt;&gt;&gt; assert itr.fold(0, lambda acc, x: acc + x) == 10\n        &gt;&gt;&gt; x = [0, 1, 2, 3, 4]\n        &gt;&gt;&gt; y = (\n        ...     iterum(x)\n        ...     .map(lambda x: x**2 + 1)\n        ...     .filter(lambda x: x % 2)\n        ...     .collect()\n        ... )\n        &gt;&gt;&gt; assert y == [1, 5, 17]\n    \"\"\"\n__slots__ = (\"_iter\",)\ndef __init__(self, __iterable: Iterable[T_co], /) -&gt; None:\nself._iter = iter(__iterable)\ndef next(self) -&gt; Option[T_co]:\n\"\"\"\n        Returns the next value in the iterable if present, otherwise [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; itr = iterum([1, 2])\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn _try_next(self._iter)\n</code></pre>"},{"location":"api/#iterum._iterum.iterum.next","title":"<code>next() -&gt; Option[T_co]</code>","text":"<p>Returns the next value in the iterable if present, otherwise nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2])\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def next(self) -&gt; Option[T_co]:\n\"\"\"\n    Returns the next value in the iterable if present, otherwise [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; itr = iterum([1, 2])\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn _try_next(self._iter)\n</code></pre>"},{"location":"api/#iterum.Iterum","title":"<code>iterum.Iterum</code>","text":"<p>         Bases: <code>Iterator[T_co]</code></p> <p>Iterator-like abstract base class. To implement this, inherit from Iterum and then define a next method. See iterum for an example.</p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Iterum(Iterator[T_co]):\n\"\"\"\n    Iterator-like abstract base class. To implement this, inherit from\n    [Iterum][iterum.Iterum] and then define a [next][iterum.Iterum.next] method.\n    See [iterum][iterum.iterum] for an example.\n    \"\"\"\n__slots__ = ()\n@abstractmethod\ndef next(self) -&gt; Option[T_co]:\n\"\"\"\n        Required method.\n        Advances the iterum and returns the next value.\n        Returns [nil][iterum.nil] when iteration is finished.\n        Individual iterum implementations may choose to resume iteration,\n        and so calling [next()][iterum.Iterum.next] again may or may not eventually start returning\n        [Some(Item)][iterum.Some] again at some point.\n        Examples:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3])\n            A call to next() returns the next value...\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == Some(3)\n            ... and then [nil][iterum.nil] once it's over.\n            &gt;&gt;&gt; assert itr.next() == nil\n            More calls may or may not return [nil][iterum.nil]. Here, they always will.\n            &gt;&gt;&gt; assert itr.next() == nil\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn nil\n@classmethod\ndef __subclasshook__(cls, C):\nif cls is Iterum:\nreturn check_methods(C, \"next\")\nreturn NotImplemented\ndef __next__(self) -&gt; T_co:\nreturn self.next().ok_or_else(StopIteration)\ndef all(self, f: Callable[[T_co], object], /) -&gt; bool:\n\"\"\"\n        Tests if every element of the iterum matches a predicate.\n        [all()][iterum.Iterum.all] takes a closure that returns `True` or `False`.\n        It applies this closure to each element of the iterum,\n        and if they all return `True`, then so does [all()][iterum.Iterum.all].\n        If any of them return `False`, it returns `False`.\n        [all()][iterum.Iterum.all] is short-circuiting; in other words, it will\n        stop processing as soon as it finds a `False`, given that no matter\n        what else happens, the result will also be `False`.\n        An empty iterum returns `True`.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; assert iterum(a).all(lambda x: x &gt; 0)\n            &gt;&gt;&gt; assert not iterum(a).all(lambda x: x &gt; 2)\n            Stopping at the first `False`:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3])\n            &gt;&gt;&gt; assert not itr.all(lambda x: x != 2)\n            &gt;&gt;&gt; assert itr.next() == Some(3)\n        \"\"\"\nreturn all(map(f, self))\ndef any(self, f: Callable[[T_co], object], /) -&gt; bool:\n\"\"\"\n        Tests if any element of the iterum matches a predicate.\n        [any()][iterum.Iterum.any] takes a closure that returns `True` or\n        `False`. It applies this closure to each element of the iterum, and if\n        any of them return `True`, then so does [any()][iterum.Iterum.any]. If\n        they all return `False`, it returns `False`.\n        [any()][iterum.Iterum.any] is short-circuiting; in other words, it will\n        stop processing as soon as it finds a `True`, given that no matter what\n        else happens, the result will also be `True`.\n        An empty iterum returns `False`.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; assert iterum(a).any(lambda x: x &gt; 0)\n            &gt;&gt;&gt; assert not iterum(a).any(lambda x: x &gt; 5)\n            Stopping at the first `True`:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3])\n            &gt;&gt;&gt; assert itr.any(lambda x: x != 2)\n            itr still has more elements.\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n        \"\"\"\nreturn any(map(f, self))\ndef chain(self: Iterum[T_co], other: Iterable[T_co], /) -&gt; Chain[T_co]:\n\"\"\"\n        Takes two iterables and creates a new iterum over both in sequence.\n        [chain()][iterum.Iterum.chain] will return a new iterum which will\n        first iterate over values from the first iteerable and then over values\n        from the second iterable.\n        In other words, it links two iterables together, in a chain.\n        Examples:\n            &gt;&gt;&gt; a1 = [1, 2, 3]\n            &gt;&gt;&gt; a2 = [4, 5, 6]\n            &gt;&gt;&gt; itr = iterum(a1).chain(a2)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == Some(3)\n            &gt;&gt;&gt; assert itr.next() == Some(4)\n            &gt;&gt;&gt; assert itr.next() == Some(5)\n            &gt;&gt;&gt; assert itr.next() == Some(6)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn Chain(self, other)\n@overload\ndef cmp(\nself: Iterum[SupportsRichComparison], other: Iterable[object], /\n) -&gt; Ordering:\n...\n@overload\ndef cmp(\nself: Iterum[object], other: Iterable[SupportsRichComparison], /\n) -&gt; Ordering:\n...\ndef cmp(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; Ordering:\n\"\"\"\n        Lexicographically compares the elements of this Iterator with those of\n        another.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1]).cmp([1]) == Ordering.Equal\n            &gt;&gt;&gt; assert iterum([1, 2]).cmp([1]) == Ordering.Greater\n            &gt;&gt;&gt; assert iterum([1]).cmp([1, 2]) == Ordering.Less\n        \"\"\"\nother = iterum(other)\nwhile True:\nmatch self.next(), other.next():\ncase Some(left), Some(right):\nif left &gt; right:  # type: ignore | reason: ask for forgiveness not permission\nreturn Ordering.Greater\nif left &lt; right:  # type: ignore | reason: ask for forgiveness not permission\nreturn Ordering.Less\ncontinue\ncase Some(), Nil():\nreturn Ordering.Greater\ncase Nil(), Some():\nreturn Ordering.Less\ncase Nil(), Nil():\nreturn Ordering.Equal\ncase _:\nraise AssertionError(\"Unreachable!\")\n@overload\ndef collect(self: Iterum[T_co], /) -&gt; list[T_co]:\n...\n@overload\ndef collect(self: Iterum[T_co], container: type[list], /) -&gt; list[T_co]:\n...\n@overload\ndef collect(self: Iterum[T_co], container: type[set], /) -&gt; set[T_co]:\n...\n@overload\ndef collect(self: Iterum[T_co], container: type[tuple], /) -&gt; tuple[T_co, ...]:\n...\n@overload\ndef collect(self: Iterum[tuple[U, V]], container: type[dict], /) -&gt; dict[U, V]:\n...\n@overload\ndef collect(self: Iterum[T_co], container: Callable[[Iterable[T_co]], U], /) -&gt; U:\n...\ndef collect(  # type: ignore\nself: Iterum[T_co], container: Callable[[Iterable[T_co]], U] = list, /\n) -&gt; U:\n\"\"\"\n        Transforms an iterum into a collection.\n        [collect()][iterum.Iterum.collect] takes a container which is responsible\n        for mapping an iterable into any type. Most commonly this is a collection\n        type such as `list` or `set` but could also be a function such as `''.join`.\n        Examples:\n            &gt;&gt;&gt; doubled = iterum([1, 2, 3]).map(lambda x: x * 2).collect(list)\n            &gt;&gt;&gt; assert doubled == [2, 4, 6]\n            using `join` to collect an iterable of `str`\n            &gt;&gt;&gt; assert iterum(\"test\").map(str.upper).collect(\"\".join) == \"TEST\"\n        \"\"\"\nreturn container(self)\ndef count(self) -&gt; int:\n\"\"\"\n        Consumes the iterum, counting the number of iterations and returning it.\n        This method will call next repeatedly until [nil][iterum.nil] is\n        encountered, returning the number of times it saw [Some][iterum.Some].\n        Note that next has to be called at least once even if the iterum does\n        not have any elements.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1, 2, 3]).count() == 3\n            &gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).count() == 5\n        \"\"\"\nlast = self.enumerate().last()\nreturn last.map_or(0, lambda last: last[0] + 1)\ndef cycle(self: Iterum[T_co], /) -&gt; Cycle[T_co]:\n\"\"\"\n        Repeats an iterum endlessly.\n        Instead of stopping at [nil][iterum.nil], the iterum will instead\n        start again, from the beginning. After iterating again, it will start at\n        the beginning again. And again. And again. Forever. Note that in case\n        the original iterum is empty, the resulting iterum will also be empty.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; it = iterum(a).cycle()\n            &gt;&gt;&gt; assert it.next() == Some(1)\n            &gt;&gt;&gt; assert it.next() == Some(2)\n            &gt;&gt;&gt; assert it.next() == Some(3)\n            &gt;&gt;&gt; assert it.next() == Some(1)\n            &gt;&gt;&gt; assert it.next() == Some(2)\n            &gt;&gt;&gt; assert it.next() == Some(3)\n            &gt;&gt;&gt; assert it.next() == Some(1)\n        \"\"\"\nreturn Cycle(self)\ndef enumerate(self: Iterum[T_co], /) -&gt; Enumerate[T_co]:\n\"\"\"\n        Creates an iterum which gives the current iteration count as well as\n        the next value.\n        The iterum returned yields pairs (i, val), where i is the current\n        index of iteration and val is the value returned by the iterum.\n        Examples:\n            &gt;&gt;&gt; a = [\"a\", \"b\", \"c\"]\n            &gt;&gt;&gt; it = iterum(a).enumerate()\n            &gt;&gt;&gt; assert it.next() == Some((0, \"a\"))\n            &gt;&gt;&gt; assert it.next() == Some((1, \"b\"))\n            &gt;&gt;&gt; assert it.next() == Some((2, \"c\"))\n            &gt;&gt;&gt; assert it.next() == nil\n        \"\"\"\nreturn Enumerate(self)\n@overload\ndef eq(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef eq(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef eq(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are equal to those of another.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1]).eq([1])\n            &gt;&gt;&gt; assert not iterum([1]).eq([1, 2])\n        \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Equal\ndef filter(\nself: Iterum[T_co], predicate: Callable[[T_co], object], /\n) -&gt; Filter[T_co]:\n\"\"\"\n        Creates an iterum which uses a closure to determine if an element\n        should be yielded.\n        Given an element the closure must return `True` or `False`. The returned\n        iterum will yield only the elements for which the closure returns `True`.\n        Examples:\n            &gt;&gt;&gt; a = [0, 1, 2]\n            &gt;&gt;&gt; it = iterum(a).filter(lambda x: x &gt; 0)\n            &gt;&gt;&gt; assert it.next() == Some(1)\n            &gt;&gt;&gt; assert it.next() == Some(2)\n            &gt;&gt;&gt; assert it.next() == nil\n        Note that `it.filter(f).next()` is equivalent to `it.find(f)`.\n        \"\"\"\nreturn Filter(self, predicate)\ndef filter_map(\nself: Iterum[T_co], predicate: Callable[[T_co], Option[U]], /\n) -&gt; FilterMap[U]:\n\"\"\"\n        Creates an iterum that both filters and maps.\n        The returned iterum yields only the values for which the supplied\n        closure returns [Some(value)][iterum.Some].\n        [filter_map][iterum.Iterum.filter_map] can be used to make chains of\n        [filter][iterum.Iterum.filter] and [map][iterum.Iterum.map] more concise.\n        Examples:\n            &gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n            ...     try:\n            ...         value = int(x)\n            ...     except ValueError:\n            ...         return nil\n            ...     else:\n            ...         return Some(value)\n            ...\n            &gt;&gt;&gt; a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"]\n            &gt;&gt;&gt; it = iterum(a).filter_map(parse2int)\n            &gt;&gt;&gt; assert it.next() == Some(1)\n            &gt;&gt;&gt; assert it.next() == Some(5)\n            &gt;&gt;&gt; assert it.next() == nil\n        \"\"\"\nreturn FilterMap(self, predicate)\ndef find(self, predicate: Callable[[T_co], object], /) -&gt; Option[T_co]:\n\"\"\"\n        Searches for an element of an iterum that satisfies a predicate.\n        [find()][iterum.Iterum.find] takes a closure that returns `True` or\n        `False`. It applies this closure to each element of the iterum, and if\n        any of them return `True`, then [find()][iterum.Iterum.find] returns\n        [Some(element)][iterum.Some]. If they all return `False`, it returns\n        [nil][iterum.nil].\n        [find()][iterum.Iterum.find] is short-circuiting; in other words, it\n        will stop processing as soon as the closure returns `True`.\n        If you need the index of the element, see [position()][iterum.Iterum.position].\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; assert iterum(a).find(lambda x: x == 2) == Some(2)\n            &gt;&gt;&gt; assert iterum(a).find(lambda x: x == 5) == nil\n            Stopping at the first `True`:\n            &gt;&gt;&gt; it = iterum([1, 2, 3])\n            &gt;&gt;&gt; assert it.find(lambda x: x == 2) == Some(2)\n            &gt;&gt;&gt; assert it.next() == Some(3)\n        Note that `it.find(f)` is equivalent to `it.filter(f).next()`.\n        \"\"\"\nfor x in self:\nif predicate(x):\nreturn Some(x)\nreturn nil\ndef find_map(self, predicate: Callable[[T_co], Option[U]], /) -&gt; Option[U]:\n\"\"\"\n        Applies function to the elements of iterum and returns the first\n        non-nil result.\n        Examples:\n            &gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n            ...     try:\n            ...         value = int(x)\n            ...     except ValueError:\n            ...         return nil\n            ...     else:\n            ...         return Some(value)\n            ...\n            &gt;&gt;&gt; a = [\"lol\", \"NaN\", \"2\", \"5\"]\n            &gt;&gt;&gt; first_number = iterum(a).find_map(parse2int)\n            &gt;&gt;&gt; assert first_number == Some(2)\n        Note that `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n        \"\"\"\nreturn self.filter_map(predicate).next()\ndef flat_map(self, f: Callable[[T_co], Iterable[U]], /) -&gt; FlatMap[U]:\n\"\"\"\n        Creates an iterum that works like map, but flattens nested structure.\n        The [map][iterum.Iterum.map] adapter is very useful, but only when the\n        closure argument produces values. If it produces an iterum instead,\n        there\u2019s an extra layer of indirection.\n        [flat_map()][iterum.Iterum.flat_map] will remove this extra layer on its own.\n        You can think of `flat_map(f)` as the semantic equivalent of mapping, and\n        then flattening as in `map(f).flatten()`.\n        Examples:\n            &gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n            &gt;&gt;&gt; merged = iterum(words).flat_map(iterum).collect(\"\".join)\n            &gt;&gt;&gt; assert merged == \"alphabetagamma\"\n        \"\"\"\nreturn FlatMap(self, f)\ndef flatten(self: Iterum[Iterable[U]]) -&gt; Flatten[U]:\n\"\"\"\n        Creates an iterum that flattens nested structure.\n        This is useful when you have an iterum of iterables and you want to\n        remove one level of indirection.\n        Examples:\n            &gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n            &gt;&gt;&gt; flattened = iterum(data).flatten().collect(list)\n            &gt;&gt;&gt; assert flattened == [1, 2, 3, 4, 5, 6]\n            Mapping and then flattening:\n            &gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n            &gt;&gt;&gt; merged = iterum(words).map(iterum).flatten().collect(\"\".join)\n            &gt;&gt;&gt; assert merged == \"alphabetagamma\"\n        \"\"\"\nreturn Flatten(self)\ndef fold(self, init: U, f: Callable[[U, T_co], U], /) -&gt; U:\n\"\"\"\n        Folds every element into an accumulator by applying an operation,\n        returning the final result.\n        [fold()][iterum.Iterum.fold] takes two arguments: an initial value, and\n        a closure with two arguments: an \u2018accumulator\u2019, and an element. The\n        closure returns the value that the accumulator should have for the next iteration.\n        The initial value is the value the accumulator will have on the first call.\n        After applying this closure to every element of the iterum, fold()\n        returns the accumulator.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; sum = iterum(a).fold(0, lambda acc, x: acc + x)\n            &gt;&gt;&gt; assert sum == 6\n            Let's walk through each step of the iteration here:\n            | element | acc | x | result |\n            | ------- | --- | - | ------ |\n            |         |  0  |   |        |\n            |   1     |  0  | 1 |   1    |\n            |   2     |  1  | 2 |   3    |\n            |   3     |  3  | 3 |   6    |\n            And so, our final result, 6.\n        fold is left-associative:\n            ```python\n            &gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n            &gt;&gt;&gt; result = iterum(numbers).fold(\"0\", lambda acc, x: f\"({acc} + {x})\")\n            &gt;&gt;&gt; assert result == \"(((((0 + 1) + 2) + 3) + 4) + 5)\"\n            ```\n        \"\"\"\nacc = init\nfor x in self:\nacc = f(acc, x)\nreturn acc\ndef for_each(self, f: Callable[[T_co], object], /) -&gt; None:\n\"\"\"\n        Calls a closure on each element of an iterum.\n        For loops are more idiomatic... but who cares!\n        Examples:\n            &gt;&gt;&gt; v = []\n            &gt;&gt;&gt; seq(5).map(lambda x: x * 2 + 1).for_each(v.append)\n            &gt;&gt;&gt; assert v == [1, 3, 5, 7, 9]\n        \"\"\"\nfor x in self:\nf(x)\ndef fuse(self) -&gt; Fuse[T_co]:\n\"\"\"\n        Creates an iterum which ends after the first [nil][iterum.nil].\n        After an iterum returns [nil][iterum.nil], future calls may or may not\n        yield [Some(T)][iterum.Some] again. [fuse()][iterum.Iterum.fuse] adapts\n        an iterum, ensuring that after a [nil][iterum.nil] is given, it will\n        always return [nil][iterum.nil] forever.\n        Examples:\n            &gt;&gt;&gt; class Alternator(Iterator[int]):\n            ...     def __init__(self) -&gt; None:\n            ...         self.i = 0\n            ...     def __next__(self) -&gt; int:\n            ...         self.i += 1\n            ...         if self.i % 5:\n            ...             return self.i\n            ...         else:\n            ...             raise StopIteration()\n            &gt;&gt;&gt; it = iterum(Alternator())\n            &gt;&gt;&gt; assert list(it) == [1, 2, 3, 4]\n            &gt;&gt;&gt; assert list(it) == [6, 7, 8, 9]\n            &gt;&gt;&gt; assert list(it) == [11, 12, 13, 14]\n            &gt;&gt;&gt; it = it.fuse()\n            &gt;&gt;&gt; assert list(it) == [16, 17, 18, 19]\n            &gt;&gt;&gt; assert list(it) == []\n            &gt;&gt;&gt; assert list(it) == []\n        \"\"\"\nreturn Fuse(self)\n@overload\ndef ge(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef ge(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef ge(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are lexicographically\n        greater than or equal to those of another.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1]).ge([1])\n            &gt;&gt;&gt; assert not iterum([1]).ge([1, 2])\n            &gt;&gt;&gt; assert iterum([1, 2]).ge([1])\n            &gt;&gt;&gt; assert iterum([1, 2]).ge([1, 2])\n        \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp in (Ordering.Greater, Ordering.Equal)\n@overload\ndef gt(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef gt(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef gt(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are lexicographically\n        greater than those of another.\n        Examples:\n            &gt;&gt;&gt; assert not iterum([1]).gt([1])\n            &gt;&gt;&gt; assert not iterum([1]).gt([1, 2])\n            &gt;&gt;&gt; assert iterum([1, 2]).gt([1])\n            &gt;&gt;&gt; assert not iterum([1, 2]).gt([1, 2])\n        \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Greater\ndef inspect(self, f: Callable[[T_co], object], /) -&gt; Inspect[T_co]:\n\"\"\"\n        Does something with each element of an iterum, passing the value on.\n        When using iterums, you\u2019ll often chain several of them together. While\n        working on such code, you might want to check out what\u2019s happening at\n        various parts in the pipeline. To do that, insert a call to\n        [inspect()][iterum.Iterum.inspect].\n        Examples:\n            &gt;&gt;&gt; s = (\n            ...    iterum([1, 4, 2, 3])\n            ...    .inspect(lambda x: print(f\"about to filter: {x}\"))\n            ...    .filter(lambda x: x % 2 == 0)\n            ...    .inspect(lambda x: print(f\"made it through filter: {x}\"))\n            ...    .fold(0, lambda sum, i: sum + i)\n            ... )\n            ...\n            about to filter: 1\n            about to filter: 4\n            made it through filter: 4\n            about to filter: 2\n            made it through filter: 2\n            about to filter: 3\n            &gt;&gt;&gt; s\n            6\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; b = []\n            &gt;&gt;&gt; c = (\n            ...     iterum(a)\n            ...     .map(lambda x: x * 2)\n            ...     .inspect(b.append)\n            ...     .take_while(lambda x: x &lt; 5)\n            ...     .collect(list)\n            ... )\n            &gt;&gt;&gt; assert b == [2, 4, 6]\n            &gt;&gt;&gt; assert c == [2, 4]\n        \"\"\"\nreturn Inspect(self, f)\ndef last(self) -&gt; Option[T_co]:\n\"\"\"\n        Consumes the iterum, returning the last element.\n        This method will evaluate the iterum until it returns\n        [nil][iterum.nil]. While doing so, it keeps track of the current\n        element. After [nil][iterum.nil] is returned, last() will then return\n        the last element it saw.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1, 2, 3]).last() == Some(3)\n            &gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).last() == Some(5)\n        \"\"\"\nlast = nil\nwhile (nxt := self.next()) is not nil:\nlast = nxt\nreturn last\n@overload\ndef le(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef le(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef le(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are lexicographically less\n        or equal to those of another.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1]).le([1])\n            &gt;&gt;&gt; assert iterum([1]).le([1, 2])\n            &gt;&gt;&gt; assert not iterum([1, 2]).le([1])\n            &gt;&gt;&gt; assert iterum([1, 2]).le([1, 2])\n        \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp in (Ordering.Less, Ordering.Equal)\n@overload\ndef lt(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef lt(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef lt(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are lexicographically less\n        than those of another.\n        Examples:\n            &gt;&gt;&gt; assert not iterum([1]).lt([1])\n            &gt;&gt;&gt; assert iterum([1]).lt([1, 2])\n            &gt;&gt;&gt; assert not iterum([1, 2]).lt([1])\n            &gt;&gt;&gt; assert not iterum([1, 2]).lt([1, 2])\n        \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Less\ndef map(self, f: Callable[[T_co], U], /) -&gt; Map[U]:\n\"\"\"\n        Takes a closure and creates an iterum which calls that closure on\n        each element.\n        [map()][iterum.Iterum.map] transforms one iterum into another, by\n        means of its argument. It produces a new iterum which calls this\n        closure on each element of the original iterum.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; itr = iterum(a).map(lambda x: x * 2)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == Some(4)\n            &gt;&gt;&gt; assert itr.next() == Some(6)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn Map(self, f)\ndef map_while(self, predicate: Callable[[T_co], Option[U]], /) -&gt; MapWhile[U]:\n\"\"\"\n        Creates an iterum that both yields elements based on a predicate and maps.\n        [map_while()][iterum.Iterum.map_while] takes a closure as an argument.\n        It will call this closure on each element of the iterum, and yield\n        elements while it returns [Some(_)][iterum.Some].\n        Examples:\n            &gt;&gt;&gt; from functools import partial\n            &gt;&gt;&gt; def checked_div(num: int, dem: int) -&gt; Option[int]:\n            ...    try:\n            ...        return Some(num // dem)\n            ...    except ZeroDivisionError:\n            ...        return nil\n            ...\n            &gt;&gt;&gt; a = [-1, 4, 0, 1]\n            &gt;&gt;&gt; it = iterum(a).map_while(partial(checked_div, 16))\n            &gt;&gt;&gt; assert it.next() == Some(-16)\n            &gt;&gt;&gt; assert it.next() == Some(4)\n            &gt;&gt;&gt; assert it.next() == nil\n            Stops after first [nil][iterum.nil]:\n            &gt;&gt;&gt; a = [0, 1, 2, -3, 4, 5, -6]\n            &gt;&gt;&gt; it = iterum(a).map_while(lambda x: Some(x) if x &gt;= 0 else nil)\n            &gt;&gt;&gt; vec = it.collect(list)\n            &gt;&gt;&gt; assert vec == [0, 1, 2]\n            &gt;&gt;&gt; assert it.next() == nil\n        \"\"\"\nreturn MapWhile(self, predicate)\ndef max(\nself: Iterum[SupportsRichComparisonT],\n) -&gt; Option[SupportsRichComparisonT]:\n\"\"\"\n        Returns the maximum element of an iterum.\n        If several elements are equally maximum, the last element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1, 2, 3]).max() == Some(3)\n            &gt;&gt;&gt; assert iterum([]).max() == nil\n        \"\"\"\ntry:\nreturn Some(builtins.max(self))\nexcept ValueError:\nreturn nil\ndef max_by(self, compare: Callable[[T_co, T_co], Ordering], /) -&gt; Option[T_co]:\n\"\"\"\n        Returns the element that gives the maximum value with respect to the\n        specified comparison function.\n        If several elements are equally maximum, the last element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n            &gt;&gt;&gt; assert iterum(a).max_by(Ordering.cmp).unwrap() == 5\n        \"\"\"\nmax_ = self.next()\nif max_ is nil:\nreturn nil\nelse:\nmax_ = max_.unwrap()\nfor nxt in self:\nif compare(max_, nxt) is Ordering.Less:\nmax_ = nxt\nreturn Some(max_)\ndef max_by_key(\nself, f: Callable[[T_co], SupportsRichComparison], /\n) -&gt; Option[T_co]:\n\"\"\"\n        Returns the element that gives the maximum value from the specified function.\n        If several elements are equally maximum, the last element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n            &gt;&gt;&gt; assert iterum(a).max_by_key(abs).unwrap() == -10\n        \"\"\"\ndef compare(x, y) -&gt; Ordering:\nfx = f(x)\nfy = f(y)\nreturn Ordering.cmp(fx, fy)\nreturn self.max_by(compare)\ndef min(\nself: Iterum[SupportsRichComparisonT],\n) -&gt; Option[SupportsRichComparisonT]:\n\"\"\"\n        Returns the minimum element of an iterum.\n        If several elements are equally minimum, the first element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1, 2, 3]).min() == Some(1)\n            &gt;&gt;&gt; assert iterum([]).min() == nil\n        \"\"\"\ntry:\nreturn Some(builtins.min(self))\nexcept ValueError:\nreturn nil\ndef min_by(self, compare: Callable[[T_co, T_co], Ordering], /) -&gt; Option[T_co]:\n\"\"\"\n        Returns the element that gives the minimum value with respect to the\n        specified comparison function.\n        If several elements are equally minimum, the first element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n            &gt;&gt;&gt; assert iterum(a).min_by(Ordering.cmp).unwrap() == -10\n        \"\"\"\nmin_ = self.next()\nif min_ is nil:\nreturn nil\nelse:\nmin_ = min_.unwrap()\nfor nxt in self:\nif compare(min_, nxt) is Ordering.Greater:\nmin_ = nxt\nreturn Some(min_)\ndef min_by_key(\nself, f: Callable[[T_co], SupportsRichComparison], /\n) -&gt; Option[T_co]:\n\"\"\"\n        Returns the element that gives the minimum value from the specified function.\n        If several elements are equally minimum, the first element is returned.\n        If the iterum is empty, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n            &gt;&gt;&gt; assert iterum(a).min_by_key(abs).unwrap() == 0\n        \"\"\"\ndef compare(x, y) -&gt; Ordering:\nfx = f(x)\nfy = f(y)\nreturn Ordering.cmp(fx, fy)\nreturn self.min_by(compare)\n@overload\ndef ne(self: Iterum[SupportsRichComparison], other: Iterable[object], /) -&gt; bool:\n...\n@overload\ndef ne(self: Iterum[object], other: Iterable[SupportsRichComparison], /) -&gt; bool:\n...\ndef ne(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n        Determines if the elements of this Iterator are not equal to those of another.\n        Examples:\n            &gt;&gt;&gt; assert not iterum([1]).ne([1])\n            &gt;&gt;&gt; assert iterum([1]).ne([1, 2])\n        \"\"\"\neq = self.eq(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn not eq\ndef nth(self, n: int, /) -&gt; Option[T_co]:\n\"\"\"\n        Returns the nth element of the iterum.\n        Like most indexing operations, the count starts from zero, so [nth(0)][iterum.Iterum.nth]\n        returns the first value, [nth(1)][iterum.Iterum.nth] the second, and so on.\n        Note that all preceding elements, as well as the returned element, will\n        be consumed from the iterum. That means that the preceding elements\n        will be discarded, and also that calling [nth(0)][iterum.Iterum.nth] multiple times on the\n        same iterum will return different elements.\n        [nth()][iterum.Iterum.nth] will return [nil][iterum.nil] if n is greater\n        than or equal to the length of the iterum.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; assert iterum(a).nth(1) == Some(2)\n            Calling [nth][iterum.Iterum.nth] multiple times doesn't rewind the iterum:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3])\n            &gt;&gt;&gt; assert itr.nth(1) == Some(2)\n            &gt;&gt;&gt; assert itr.nth(1) == nil\n            Returns [nil][iterum.nil] if there are less than `n + 1` elements:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3])\n            &gt;&gt;&gt; assert itr.nth(3) == nil\n        \"\"\"\nfor i, x in enumerate(self):\nif i &gt; n:\nreturn nil\nif i == n:\nreturn Some(x)\nreturn nil\n@overload\ndef partial_cmp(\nself: Iterum[SupportsRichComparison], other: Iterable[object], /\n) -&gt; Some[Ordering]:\n...\n@overload\ndef partial_cmp(\nself: Iterum[object], other: Iterable[SupportsRichComparison], /\n) -&gt; Some[Ordering]:\n...\n@overload\ndef partial_cmp(self: Iterum[object], other: Iterable[object], /) -&gt; Nil:\n...\ndef partial_cmp(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; Option[Ordering]:\n\"\"\"\n        Lexicographically compares the PartialOrd elements of this Iterator with\n        those of another. The comparison works like short-circuit evaluation,\n        returning a result without comparing the remaining elements. As soon as\n        an order can be determined, the evaluation stops and a result is returned.\n        Examples:\n            &gt;&gt;&gt; assert iterum([1]).partial_cmp([1]) == Some(Ordering.Equal)\n            &gt;&gt;&gt; assert iterum([1, 2]).partial_cmp([1]) == Some(Ordering.Greater)\n            &gt;&gt;&gt; assert iterum([1]).partial_cmp([1, 2]) == Some(Ordering.Less)\n            Results are determined by the order of evaluation:\n            &gt;&gt;&gt; assert iterum([1, None]).partial_cmp([2, nil]) == Some(Ordering.Less)\n            &gt;&gt;&gt; assert iterum([2, None]).partial_cmp([1, nil]) == Some(Ordering.Greater)\n            &gt;&gt;&gt; assert iterum([None, 1]).partial_cmp([2, None]) == nil\n        \"\"\"\ntry:\nvalue = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nexcept TypeError:\nreturn nil\nelse:\nreturn Some(value)\n@overload\ndef partition(\nself, f: Callable[[T_co], object], /\n) -&gt; tuple[list[T_co], list[T_co]]:\n...\n@overload\ndef partition(\nself, f: Callable[[T_co], object], container: type[list], /\n) -&gt; tuple[list[T_co], list[T_co]]:\n...\n@overload\ndef partition(\nself, f: Callable[[T_co], object], container: type[set], /\n) -&gt; tuple[set[T_co], set[T_co]]:\n...\n@overload\ndef partition(\nself, f: Callable[[T_co], object], container: type[tuple], /\n) -&gt; tuple[tuple[T_co, ...], tuple[T_co, ...]]:\n...\n@overload\ndef partition(\nself: Iterum[tuple[U, V]], f: Callable[[T_co], object], container: type[dict], /\n) -&gt; tuple[dict[U, V], dict[U, V]]:\n...\n@overload\ndef partition(\nself, f: Callable[[T_co], object], container: Callable[[Iterable[T_co]], U], /\n) -&gt; tuple[U, U]:\n...\ndef partition(  # type: ignore\nself,\nf: Callable[[T_co], object],\ncontainer: Callable[[Iterable[T_co]], U] = list,\n/,\n) -&gt; tuple[U, U]:\n\"\"\"\n        Consumes an iterum, creating two collections from it.\n        The predicate passed to [partition()][iterum.Iterum.partition] can\n        return `True`, or `False`. [partition()][iterum.Iterum.partition]\n        returns a pair, all of the elements for which it returned `True`, and\n        all of the elements for which it returned `False`.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; even, odd = iterum(a).partition(lambda n: n % 2 == 0)\n            &gt;&gt;&gt; assert even == [2]\n            &gt;&gt;&gt; assert odd == [1, 3]\n        \"\"\"\nmatches, notmatches = [], []\nfor x in self:\nmatches.append(x) if f(x) else notmatches.append(x)\nreturn container(matches), container(notmatches)\ndef peekable(self) -&gt; Peekable[T_co]:\n\"\"\"\n        Creates an iterum which provides a peek attribute for viewing\n        and setting the next element of the iterum without consuming it.\n        Examples:\n            &gt;&gt;&gt; xs = [1, 2, 3]\n            &gt;&gt;&gt; itr = iterum(xs).peekable()\n            &gt;&gt;&gt; assert itr.peek == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.peek == Some(3)\n            &gt;&gt;&gt; assert itr.peek == Some(3)\n            &gt;&gt;&gt; assert itr.next() == Some(3)\n            &gt;&gt;&gt; assert itr.peek == nil\n            &gt;&gt;&gt; assert itr.next() == nil\n            &gt;&gt;&gt; xs = [1, 2, 3]\n            &gt;&gt;&gt; itr = iterum(xs).peekable()\n            &gt;&gt;&gt; assert itr.peek == Some(1)\n            &gt;&gt;&gt; assert itr.peek == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.peek == Some(2)\n            &gt;&gt;&gt; itr.peek = 1000\n            &gt;&gt;&gt; assert list(itr) == [1000, 3]\n        \"\"\"\nreturn Peekable(self)\ndef position(self, predicate: Callable[[T_co], object], /) -&gt; Option[int]:\n\"\"\"\n        Searches for an element in an iterum, returning its index.\n        [position()][iterum.Iterum.position] takes a closure that returns `True`\n        or `False`. It applies this closure to each element of the iterum, and\n        if one of them returns `True`, then [position()][iterum.Iterum.position]\n        returns [Some(index)][iterum.Some]. If all of them return `False`, it\n        returns [nil][iterum.nil].\n        [position()][iterum.Iterum.position] is short-circuiting; in other\n        words, it will stop processing as soon as it finds a `True`.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; assert iterum(a).position(lambda x: x == 2) == Some(1)\n            &gt;&gt;&gt; assert iterum(a).position(lambda x: x == 5) == nil\n            &gt;&gt;&gt; it = iterum([1, 2, 3, 4])\n            &gt;&gt;&gt; assert it.position(lambda x: x &gt;= 2) == Some(1)\n            &gt;&gt;&gt; assert it.next() == Some(3)\n            &gt;&gt;&gt; assert it.position(lambda x: x == 4) == Some(0)\n        \"\"\"\nfor i, x in enumerate(self):\nif predicate(x):\nreturn Some(i)\nreturn nil\ndef product(self: Iterum[SupportsMulT]) -&gt; Option[SupportsMulT]:\n\"\"\"\n        Iterates over the entire iterum, multiplying all the elements\n        An empty iterum returns [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; def factorial(n: int) -&gt; int:\n            ...     return seq(1, n + 1).product().unwrap_or(1)\n            ...\n            &gt;&gt;&gt; assert factorial(0) == 1\n            &gt;&gt;&gt; assert factorial(1) == 1\n            &gt;&gt;&gt; assert factorial(5) == 120\n        \"\"\"\nreturn self.reduce(lambda acc, x: acc * x)\ndef reduce(self, f: Callable[[T_co, T_co], T_co], /) -&gt; Option[T_co]:\n\"\"\"\n        Reduces the elements to a single one, by repeatedly applying a reducing operation.\n        If the iterum is empty, returns [nil][iterum.nil]; otherwise, returns\n        the result of the reduction.\n        The reducing function is a closure with two arguments: an \u2018accumulator\u2019,\n        and an element. For iterums with at least one element, this is the\n        same as [fold()][iterum.Iterum.fold] with the first element of the\n        iterum as the initial accumulator value, folding every subsequent\n        element into it.\n        Examples:\n            &gt;&gt;&gt; reduced = seq(1, 10).reduce(lambda acc, e: acc + e).unwrap()\n            &gt;&gt;&gt; assert reduced == 45\n        \"\"\"\nfirst = self.next()\nif first is nil:\nreturn nil\nelse:\nreturn Some(self.fold(first.unwrap(), f))\ndef scan(self, init: U, f: Callable[[State[U], T_co], Option[V]], /) -&gt; Scan[V]:\n\"\"\"\n        An iterum adapter which, like fold, holds internal state, but unlike\n        fold, produces a new iterum.\n        [scan()][iterum.Iterum.scan] takes two arguments: an initial value which\n        seeds the internal state, and a closure with two arguments, the first\n        being the internal state and the second an iterum element.\n        The closure can assign to the internal state to share state between iterations.\n        Examples:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3, 4])\n            &gt;&gt;&gt; def scanner(state: State, x: int) -&gt; Option[int]:\n            ...     state.value *= x\n            ...     if state.value &gt; 6:\n            ...         return nil\n            ...     return Some(-state.value)\n            ...\n            &gt;&gt;&gt; scan = itr.scan(1, scanner)\n            &gt;&gt;&gt; assert scan.next() == Some(-1)\n            &gt;&gt;&gt; assert scan.next() == Some(-2)\n            &gt;&gt;&gt; assert scan.next() == Some(-6)\n            &gt;&gt;&gt; assert scan.next() == nil\n        \"\"\"\nreturn Scan(self, init, f)\n# def size_hint ..., don't plan on implementing this one. Just use diterum if size is important\ndef skip(self, n: int, /) -&gt; Skip[T_co]:\n\"\"\"\n        Creates an iterum that skips the first n elements.\n        [skip(n)][iterum.Iterum.skip] skips elements until n elements are\n        skipped or the end of the iterum is reached (whichever happens first).\n        After that, all the remaining elements are yielded. In particular, if\n        the original iterum is too short, then the returned iterum is empty.\n        Examples:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(2)\n            &gt;&gt;&gt; assert itr.next() == Some(3)\n            &gt;&gt;&gt; assert itr.next() == nil\n            Skipping past end:\n            &gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(10)\n            &gt;&gt;&gt; assert itr.next() == nil\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn Skip(self, n)\ndef skip_while(self, predicate: Callable[[T_co], object], /) -&gt; SkipWhile[T_co]:\n\"\"\"\n        Creates an iterum that skips elements based on a predicate.\n        [skip_while()][iterum.Iterum.skip_while] takes a closure as an argument.\n        It will call this closure on each element of the iterum, and ignore\n        elements until it returns `False`.\n        After `False` is returned, [skip_while()][iterum.Iterum.skip_while]\u2019s\n        job is over, and the rest of the elements are yielded.\n        Examples:\n            &gt;&gt;&gt; itr = iterum([-1, 0, 1]).skip_while(lambda x: x &lt; 0)\n            &gt;&gt;&gt; assert itr.next() == Some(0)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == nil\n            After first `False` condition is hit, no further elements are checked:\n            &gt;&gt;&gt; itr = iterum([-1, 0, 1, -3]).skip_while(lambda x: x &lt; 0)\n            &gt;&gt;&gt; assert itr.next() == Some(0)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(-3)\n        \"\"\"\nreturn SkipWhile(self, predicate)\ndef step_by(self, step: int, /) -&gt; StepBy[T_co]:\n\"\"\"\n        Creates an iterum starting at the same point, but stepping by the\n        given amount at each iteration. This always includes the first element.\n        Examples:\n            &gt;&gt;&gt; itr = iterum([0, 1, 2, 3, 4, 5]).step_by(2)\n            &gt;&gt;&gt; assert itr.next() == Some(0)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == Some(4)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn StepBy(self, step)\ndef sum(self: Iterum[SupportsSumNoDefaultT]) -&gt; Option[SupportsSumNoDefaultT]:\n\"\"\"\n        Sums the elements of an iterum.\n        Takes each element, adds them together, and returns the result.\n        An empty iterum returns [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; sum_ = iterum(a).sum().unwrap_or(0)\n            &gt;&gt;&gt; assert sum_ == 6\n            &gt;&gt;&gt; sum_ = iterum([]).sum().unwrap_or(0)\n            &gt;&gt;&gt; assert sum_ == 0\n        \"\"\"\n# NOTE: This forces users to pick a default or suffer the unwrapping consequences\n# a more reasonable interface since an implicit default isn't a thing\nfirst = self.next()\nif first is nil:\nreturn nil\nreturn Some(sum(self, start=first.unwrap()))\ndef take(self, n: int, /) -&gt; Take[T_co]:\n\"\"\"\n        Creates an iterum that yields the first n elements, or fewer if the\n        underlying iterum ends sooner.\n        [take(n)][iterum.Iterum.take] yields elements until n elements are\n        yielded or the end of the iterum is reached (whichever happens first).\n        The returned iterum is a prefix of length n if the original iterum\n        contains at least n elements, otherwise it contains all of the (fewer\n        than n) elements of the original iterum.\n        Examples:\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; itr = iterum(a).take(2)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == nil\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; itr = iterum(a).take(2)\n            &gt;&gt;&gt; assert list(itr) == [1, 2]\n            &gt;&gt;&gt; assert itr.next() == nil\n            Truncate an infinite iterum:\n            &gt;&gt;&gt; itr = seq(...).take(3)\n            &gt;&gt;&gt; assert itr.next() == Some(0)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == nil\n            Taking more than you have:\n            &gt;&gt;&gt; itr = iterum([1, 2]).take(5)\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn Take(self, n)\ndef take_while(self, predicate: Callable[[T_co], object], /) -&gt; TakeWhile[T_co]:\n\"\"\"\n        Creates an iterum that yields elements based on a predicate.\n        [take_while()][iterum.Iterum.take_while] takes a closure as an argument.\n        It will call this closure on each element of the iterum, and yield\n        elements while it returns `True`.\n        After `False` is returned, [take_while()][iterum.Iterum.take_while]\u2019s\n        job is over, and the rest of the elements are ignored.\n        Examples:\n            &gt;&gt;&gt; a = [-1, 0, 1]\n            &gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n            &gt;&gt;&gt; assert itr.next() == Some(-1)\n            &gt;&gt;&gt; assert itr.next() == nil\n            Stop after first `False`:\n            &gt;&gt;&gt; a = [-1, 0, 1, -2]\n            &gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n            &gt;&gt;&gt; assert itr.next() == Some(-1)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nreturn TakeWhile(self, predicate)\ndef try_fold(\nself,\ninit: U,\nf: Callable[[U, T_co], U],\n/,\n*,\nexception: type[BaseException] | tuple[type[BaseException], ...] = Exception,\n) -&gt; Option[U]:\n\"\"\"\n        An iterum method that applies a function as long as it returns\n        successfully, producing a single, final value.\n        [try_fold()][iterum.Iterum.try_fold] takes two arguments: an initial\n        value, and a closure with two arguments: an \u2018accumulator\u2019, and an\n        element. The closure either returns successfully, with the value that\n        the accumulator should have for the next iteration, or it raises an\n        exception which short-circuits the iteration.\n        Examples:\n            &gt;&gt;&gt; def checked_add_i8(lhs: int, rhs: int) -&gt; int:\n            ...     value = lhs + rhs\n            ...     if -128 &lt;= value &lt;= 127:\n            ...         return value\n            ...     else:\n            ...         raise ValueError(\"Overflow!\")\n            ...\n            &gt;&gt;&gt; a = [1, 2, 3]\n            &gt;&gt;&gt; sum = iterum(a).try_fold(0, checked_add_i8)\n            &gt;&gt;&gt; assert sum == Some(6)\n            short-circuit after a failure:\n            &gt;&gt;&gt; it = iterum([10, 20, 30, 100, 40, 50])\n            &gt;&gt;&gt; sum = it.try_fold(0, checked_add_i8)\n            &gt;&gt;&gt; assert sum == nil\n            &gt;&gt;&gt; assert list(it) == [40, 50]\n        \"\"\"\nacc = init\nfor x in self:\ntry:\nacc = f(acc, x)\nexcept exception:\nreturn nil\nreturn Some(acc)\n# This would be the same as a for each...\n# def try_for_each(self, f: Callable[[T], object], /) -&gt; None:\n#     for x in self:\n#         try:\n#             f(x)\n#         except Exception:\n#             return\n@overload\ndef unzip(self: Iterum[tuple[U, V]], /) -&gt; tuple[list[U], list[V]]:\n...\n@overload\ndef unzip(\nself: Iterum[tuple[U, V]], container: type[list], /\n) -&gt; tuple[list[U], list[V]]:\n...\n@overload\ndef unzip(\nself: Iterum[tuple[U, V]], container: type[set], /\n) -&gt; tuple[set[U], set[V]]:\n...\n@overload\ndef unzip(\nself: Iterum[tuple[U, V]], container: type[tuple], /\n) -&gt; tuple[tuple[U, ...], tuple[V, ...]]:\n...\n@overload\ndef unzip(\nself: Iterum[tuple[object, object]],\ncontainer: Callable[[Iterable[object]], U],\n/,\n) -&gt; tuple[U, U]:\n...\ndef unzip(\nself: Iterum[tuple[object, object]],\ncontainer: Callable[[Iterable[object]], U] = list,\n/,\n) -&gt; tuple[U, U]:\n\"\"\"\n        Converts an iterum of pairs into a pair of containers.\n        [unzip()][iterum.Iterum.unzip] consumes an entire iterum of pairs,\n        producing two collections: one from the left elements of the pairs, and\n        one from the right elements.\n        This function is, in some sense, the opposite of [zip][iterum.Iterum.zip].\n        Examples:\n            &gt;&gt;&gt; a = [(1, 2), (3, 4), (5, 6)]\n            &gt;&gt;&gt; left, right = iterum(a).unzip()\n            &gt;&gt;&gt; assert left == [1, 3, 5]\n            &gt;&gt;&gt; assert right == [2, 4, 6]\n        \"\"\"\nleft, right = map(container, zip(*self))\nreturn left, right\ndef zip(self, other: Iterable[U], /) -&gt; Zip[T_co, U]:\n\"\"\"\n        \u2018Zips up\u2019 two iterables into a single iterum of pairs.\n        [zip()][iterum.Iterum.zip] returns a new iterum that will iterate over\n        two other iterables, returning a tuple where the first element comes\n        from the first iterable, and the second element comes from the second iterable.\n        If either iterable returns [nil][iterum.nil], next from the zipped\n        iterum will return [nil][iterum.nil]. If the zipped iterum has no\n        more elements to return then each further attempt to advance it will\n        first try to advance the first iterable at most one time and if it still\n        yielded an item try to advance the second iterable at most one time.\n        To \u2018undo\u2019 the result of zipping up two iterables, see [unzip][iterum.Iterum.unzip].\n        Examples:\n            &gt;&gt;&gt; a1 = [1, 2, 3]\n            &gt;&gt;&gt; a2 = [4, 5, 6]\n            &gt;&gt;&gt; itr = iterum(a1).zip(a2)\n            &gt;&gt;&gt; assert itr.next() == Some((1, 4))\n            &gt;&gt;&gt; assert itr.next() == Some((2, 5))\n            &gt;&gt;&gt; assert itr.next() == Some((3, 6))\n            &gt;&gt;&gt; assert itr.next() == nil\n            zip smaller with larger:\n            &gt;&gt;&gt; inf_itr = seq(...)\n            &gt;&gt;&gt; foo_itr = iterum(\"foo\")\n            &gt;&gt;&gt; zip_itr = foo_itr.zip(inf_itr)\n            &gt;&gt;&gt; assert zip_itr.next() == Some((\"f\", 0))\n            &gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 1))\n            &gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 2))\n            &gt;&gt;&gt; assert zip_itr.next() == nil\n            &gt;&gt;&gt; assert foo_itr.next() == nil\n            &gt;&gt;&gt; assert inf_itr.next() == Some(3)\n            zip larger with smaller:\n            &gt;&gt;&gt; inf_itr = seq(...)\n            &gt;&gt;&gt; foo_itr = iterum(\"foo\")\n            &gt;&gt;&gt; zip_itr = inf_itr.zip(foo_itr)\n            &gt;&gt;&gt; assert zip_itr.next() == Some((0, \"f\"))\n            &gt;&gt;&gt; assert zip_itr.next() == Some((1, \"o\"))\n            &gt;&gt;&gt; assert zip_itr.next() == Some((2, \"o\"))\n            &gt;&gt;&gt; assert zip_itr.next() == nil\n            &gt;&gt;&gt; assert foo_itr.next() == nil\n            &gt;&gt;&gt; assert inf_itr.next() == Some(4)\n        \"\"\"\nreturn Zip(self, other)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.next","title":"<code>next() -&gt; Option[T_co]</code>  <code>abstractmethod</code>","text":"<p>Required method.</p> <p>Advances the iterum and returns the next value.</p> <p>Returns nil when iteration is finished. Individual iterum implementations may choose to resume iteration, and so calling next() again may or may not eventually start returning Some(Item) again at some point.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3])\n</code></pre> <p>A call to next() returns the next value...</p> <pre><code>&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n</code></pre> <p>... and then nil once it's over.</p> <pre><code>&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>More calls may or may not return nil. Here, they always will.</p> <pre><code>&gt;&gt;&gt; assert itr.next() == nil\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>@abstractmethod\ndef next(self) -&gt; Option[T_co]:\n\"\"\"\n    Required method.\n    Advances the iterum and returns the next value.\n    Returns [nil][iterum.nil] when iteration is finished.\n    Individual iterum implementations may choose to resume iteration,\n    and so calling [next()][iterum.Iterum.next] again may or may not eventually start returning\n    [Some(Item)][iterum.Some] again at some point.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3])\n        A call to next() returns the next value...\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n        ... and then [nil][iterum.nil] once it's over.\n        &gt;&gt;&gt; assert itr.next() == nil\n        More calls may or may not return [nil][iterum.nil]. Here, they always will.\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.all","title":"<code>all(f: Callable[[T_co], object]) -&gt; bool</code>","text":"<p>Tests if every element of the iterum matches a predicate.</p> <p>all() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the iterum, and if they all return <code>True</code>, then so does all(). If any of them return <code>False</code>, it returns <code>False</code>.</p> <p>all() is short-circuiting; in other words, it will stop processing as soon as it finds a <code>False</code>, given that no matter what else happens, the result will also be <code>False</code>.</p> <p>An empty iterum returns <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; assert iterum(a).all(lambda x: x &gt; 0)\n&gt;&gt;&gt; assert not iterum(a).all(lambda x: x &gt; 2)\n</code></pre> <p>Stopping at the first <code>False</code>:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3])\n&gt;&gt;&gt; assert not itr.all(lambda x: x != 2)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def all(self, f: Callable[[T_co], object], /) -&gt; bool:\n\"\"\"\n    Tests if every element of the iterum matches a predicate.\n    [all()][iterum.Iterum.all] takes a closure that returns `True` or `False`.\n    It applies this closure to each element of the iterum,\n    and if they all return `True`, then so does [all()][iterum.Iterum.all].\n    If any of them return `False`, it returns `False`.\n    [all()][iterum.Iterum.all] is short-circuiting; in other words, it will\n    stop processing as soon as it finds a `False`, given that no matter\n    what else happens, the result will also be `False`.\n    An empty iterum returns `True`.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; assert iterum(a).all(lambda x: x &gt; 0)\n        &gt;&gt;&gt; assert not iterum(a).all(lambda x: x &gt; 2)\n        Stopping at the first `False`:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3])\n        &gt;&gt;&gt; assert not itr.all(lambda x: x != 2)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n    \"\"\"\nreturn all(map(f, self))\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.any","title":"<code>any(f: Callable[[T_co], object]) -&gt; bool</code>","text":"<p>Tests if any element of the iterum matches a predicate.</p> <p>any() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the iterum, and if any of them return <code>True</code>, then so does any(). If they all return <code>False</code>, it returns <code>False</code>.</p> <p>any() is short-circuiting; in other words, it will stop processing as soon as it finds a <code>True</code>, given that no matter what else happens, the result will also be <code>True</code>.</p> <p>An empty iterum returns <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; assert iterum(a).any(lambda x: x &gt; 0)\n&gt;&gt;&gt; assert not iterum(a).any(lambda x: x &gt; 5)\n</code></pre> <p>Stopping at the first <code>True</code>:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3])\n&gt;&gt;&gt; assert itr.any(lambda x: x != 2)\n</code></pre> <p>itr still has more elements.</p> <pre><code>&gt;&gt;&gt; assert itr.next() == Some(2)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def any(self, f: Callable[[T_co], object], /) -&gt; bool:\n\"\"\"\n    Tests if any element of the iterum matches a predicate.\n    [any()][iterum.Iterum.any] takes a closure that returns `True` or\n    `False`. It applies this closure to each element of the iterum, and if\n    any of them return `True`, then so does [any()][iterum.Iterum.any]. If\n    they all return `False`, it returns `False`.\n    [any()][iterum.Iterum.any] is short-circuiting; in other words, it will\n    stop processing as soon as it finds a `True`, given that no matter what\n    else happens, the result will also be `True`.\n    An empty iterum returns `False`.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; assert iterum(a).any(lambda x: x &gt; 0)\n        &gt;&gt;&gt; assert not iterum(a).any(lambda x: x &gt; 5)\n        Stopping at the first `True`:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3])\n        &gt;&gt;&gt; assert itr.any(lambda x: x != 2)\n        itr still has more elements.\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n    \"\"\"\nreturn any(map(f, self))\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.chain","title":"<code>chain(other: Iterable[T_co]) -&gt; Chain[T_co]</code>","text":"<p>Takes two iterables and creates a new iterum over both in sequence.</p> <p>chain() will return a new iterum which will first iterate over values from the first iteerable and then over values from the second iterable.</p> <p>In other words, it links two iterables together, in a chain.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a1 = [1, 2, 3]\n&gt;&gt;&gt; a2 = [4, 5, 6]\n&gt;&gt;&gt; itr = iterum(a1).chain(a2)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n&gt;&gt;&gt; assert itr.next() == Some(4)\n&gt;&gt;&gt; assert itr.next() == Some(5)\n&gt;&gt;&gt; assert itr.next() == Some(6)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def chain(self: Iterum[T_co], other: Iterable[T_co], /) -&gt; Chain[T_co]:\n\"\"\"\n    Takes two iterables and creates a new iterum over both in sequence.\n    [chain()][iterum.Iterum.chain] will return a new iterum which will\n    first iterate over values from the first iteerable and then over values\n    from the second iterable.\n    In other words, it links two iterables together, in a chain.\n    Examples:\n        &gt;&gt;&gt; a1 = [1, 2, 3]\n        &gt;&gt;&gt; a2 = [4, 5, 6]\n        &gt;&gt;&gt; itr = iterum(a1).chain(a2)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n        &gt;&gt;&gt; assert itr.next() == Some(4)\n        &gt;&gt;&gt; assert itr.next() == Some(5)\n        &gt;&gt;&gt; assert itr.next() == Some(6)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn Chain(self, other)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.cmp","title":"<code>cmp(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; Ordering</code>","text":"<p>Lexicographically compares the elements of this Iterator with those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1]).cmp([1]) == Ordering.Equal\n&gt;&gt;&gt; assert iterum([1, 2]).cmp([1]) == Ordering.Greater\n&gt;&gt;&gt; assert iterum([1]).cmp([1, 2]) == Ordering.Less\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def cmp(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; Ordering:\n\"\"\"\n    Lexicographically compares the elements of this Iterator with those of\n    another.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1]).cmp([1]) == Ordering.Equal\n        &gt;&gt;&gt; assert iterum([1, 2]).cmp([1]) == Ordering.Greater\n        &gt;&gt;&gt; assert iterum([1]).cmp([1, 2]) == Ordering.Less\n    \"\"\"\nother = iterum(other)\nwhile True:\nmatch self.next(), other.next():\ncase Some(left), Some(right):\nif left &gt; right:  # type: ignore | reason: ask for forgiveness not permission\nreturn Ordering.Greater\nif left &lt; right:  # type: ignore | reason: ask for forgiveness not permission\nreturn Ordering.Less\ncontinue\ncase Some(), Nil():\nreturn Ordering.Greater\ncase Nil(), Some():\nreturn Ordering.Less\ncase Nil(), Nil():\nreturn Ordering.Equal\ncase _:\nraise AssertionError(\"Unreachable!\")\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.collect","title":"<code>collect(container: Callable[[Iterable[T_co]], U] = list) -&gt; U</code>","text":"<p>Transforms an iterum into a collection.</p> <p>collect() takes a container which is responsible for mapping an iterable into any type. Most commonly this is a collection type such as <code>list</code> or <code>set</code> but could also be a function such as <code>''.join</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; doubled = iterum([1, 2, 3]).map(lambda x: x * 2).collect(list)\n&gt;&gt;&gt; assert doubled == [2, 4, 6]\n</code></pre> <p>using <code>join</code> to collect an iterable of <code>str</code></p> <pre><code>&gt;&gt;&gt; assert iterum(\"test\").map(str.upper).collect(\"\".join) == \"TEST\"\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def collect(  # type: ignore\nself: Iterum[T_co], container: Callable[[Iterable[T_co]], U] = list, /\n) -&gt; U:\n\"\"\"\n    Transforms an iterum into a collection.\n    [collect()][iterum.Iterum.collect] takes a container which is responsible\n    for mapping an iterable into any type. Most commonly this is a collection\n    type such as `list` or `set` but could also be a function such as `''.join`.\n    Examples:\n        &gt;&gt;&gt; doubled = iterum([1, 2, 3]).map(lambda x: x * 2).collect(list)\n        &gt;&gt;&gt; assert doubled == [2, 4, 6]\n        using `join` to collect an iterable of `str`\n        &gt;&gt;&gt; assert iterum(\"test\").map(str.upper).collect(\"\".join) == \"TEST\"\n    \"\"\"\nreturn container(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.count","title":"<code>count() -&gt; int</code>","text":"<p>Consumes the iterum, counting the number of iterations and returning it.</p> <p>This method will call next repeatedly until nil is encountered, returning the number of times it saw Some. Note that next has to be called at least once even if the iterum does not have any elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1, 2, 3]).count() == 3\n&gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).count() == 5\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def count(self) -&gt; int:\n\"\"\"\n    Consumes the iterum, counting the number of iterations and returning it.\n    This method will call next repeatedly until [nil][iterum.nil] is\n    encountered, returning the number of times it saw [Some][iterum.Some].\n    Note that next has to be called at least once even if the iterum does\n    not have any elements.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1, 2, 3]).count() == 3\n        &gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).count() == 5\n    \"\"\"\nlast = self.enumerate().last()\nreturn last.map_or(0, lambda last: last[0] + 1)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.cycle","title":"<code>cycle() -&gt; Cycle[T_co]</code>","text":"<p>Repeats an iterum endlessly.</p> <p>Instead of stopping at nil, the iterum will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever. Note that in case the original iterum is empty, the resulting iterum will also be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; it = iterum(a).cycle()\n&gt;&gt;&gt; assert it.next() == Some(1)\n&gt;&gt;&gt; assert it.next() == Some(2)\n&gt;&gt;&gt; assert it.next() == Some(3)\n&gt;&gt;&gt; assert it.next() == Some(1)\n&gt;&gt;&gt; assert it.next() == Some(2)\n&gt;&gt;&gt; assert it.next() == Some(3)\n&gt;&gt;&gt; assert it.next() == Some(1)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def cycle(self: Iterum[T_co], /) -&gt; Cycle[T_co]:\n\"\"\"\n    Repeats an iterum endlessly.\n    Instead of stopping at [nil][iterum.nil], the iterum will instead\n    start again, from the beginning. After iterating again, it will start at\n    the beginning again. And again. And again. Forever. Note that in case\n    the original iterum is empty, the resulting iterum will also be empty.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; it = iterum(a).cycle()\n        &gt;&gt;&gt; assert it.next() == Some(1)\n        &gt;&gt;&gt; assert it.next() == Some(2)\n        &gt;&gt;&gt; assert it.next() == Some(3)\n        &gt;&gt;&gt; assert it.next() == Some(1)\n        &gt;&gt;&gt; assert it.next() == Some(2)\n        &gt;&gt;&gt; assert it.next() == Some(3)\n        &gt;&gt;&gt; assert it.next() == Some(1)\n    \"\"\"\nreturn Cycle(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.enumerate","title":"<code>enumerate() -&gt; Enumerate[T_co]</code>","text":"<p>Creates an iterum which gives the current iteration count as well as the next value.</p> <p>The iterum returned yields pairs (i, val), where i is the current index of iteration and val is the value returned by the iterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [\"a\", \"b\", \"c\"]\n&gt;&gt;&gt; it = iterum(a).enumerate()\n&gt;&gt;&gt; assert it.next() == Some((0, \"a\"))\n&gt;&gt;&gt; assert it.next() == Some((1, \"b\"))\n&gt;&gt;&gt; assert it.next() == Some((2, \"c\"))\n&gt;&gt;&gt; assert it.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def enumerate(self: Iterum[T_co], /) -&gt; Enumerate[T_co]:\n\"\"\"\n    Creates an iterum which gives the current iteration count as well as\n    the next value.\n    The iterum returned yields pairs (i, val), where i is the current\n    index of iteration and val is the value returned by the iterum.\n    Examples:\n        &gt;&gt;&gt; a = [\"a\", \"b\", \"c\"]\n        &gt;&gt;&gt; it = iterum(a).enumerate()\n        &gt;&gt;&gt; assert it.next() == Some((0, \"a\"))\n        &gt;&gt;&gt; assert it.next() == Some((1, \"b\"))\n        &gt;&gt;&gt; assert it.next() == Some((2, \"c\"))\n        &gt;&gt;&gt; assert it.next() == nil\n    \"\"\"\nreturn Enumerate(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.eq","title":"<code>eq(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are equal to those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1]).eq([1])\n&gt;&gt;&gt; assert not iterum([1]).eq([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def eq(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are equal to those of another.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1]).eq([1])\n        &gt;&gt;&gt; assert not iterum([1]).eq([1, 2])\n    \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Equal\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.filter","title":"<code>filter(predicate: Callable[[T_co], object]) -&gt; Filter[T_co]</code>","text":"<p>Creates an iterum which uses a closure to determine if an element should be yielded.</p> <p>Given an element the closure must return <code>True</code> or <code>False</code>. The returned iterum will yield only the elements for which the closure returns <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [0, 1, 2]\n&gt;&gt;&gt; it = iterum(a).filter(lambda x: x &gt; 0)\n&gt;&gt;&gt; assert it.next() == Some(1)\n&gt;&gt;&gt; assert it.next() == Some(2)\n&gt;&gt;&gt; assert it.next() == nil\n</code></pre> <p>Note that <code>it.filter(f).next()</code> is equivalent to <code>it.find(f)</code>.</p> Source code in <code>iterum/_iterum.py</code> <pre><code>def filter(\nself: Iterum[T_co], predicate: Callable[[T_co], object], /\n) -&gt; Filter[T_co]:\n\"\"\"\n    Creates an iterum which uses a closure to determine if an element\n    should be yielded.\n    Given an element the closure must return `True` or `False`. The returned\n    iterum will yield only the elements for which the closure returns `True`.\n    Examples:\n        &gt;&gt;&gt; a = [0, 1, 2]\n        &gt;&gt;&gt; it = iterum(a).filter(lambda x: x &gt; 0)\n        &gt;&gt;&gt; assert it.next() == Some(1)\n        &gt;&gt;&gt; assert it.next() == Some(2)\n        &gt;&gt;&gt; assert it.next() == nil\n    Note that `it.filter(f).next()` is equivalent to `it.find(f)`.\n    \"\"\"\nreturn Filter(self, predicate)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.filter_map","title":"<code>filter_map(predicate: Callable[[T_co], Option[U]]) -&gt; FilterMap[U]</code>","text":"<p>Creates an iterum that both filters and maps.</p> <p>The returned iterum yields only the values for which the supplied closure returns Some(value).</p> <p>filter_map can be used to make chains of filter and map more concise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n...     try:\n...         value = int(x)\n...     except ValueError:\n...         return nil\n...     else:\n...         return Some(value)\n...\n&gt;&gt;&gt; a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"]\n&gt;&gt;&gt; it = iterum(a).filter_map(parse2int)\n&gt;&gt;&gt; assert it.next() == Some(1)\n&gt;&gt;&gt; assert it.next() == Some(5)\n&gt;&gt;&gt; assert it.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def filter_map(\nself: Iterum[T_co], predicate: Callable[[T_co], Option[U]], /\n) -&gt; FilterMap[U]:\n\"\"\"\n    Creates an iterum that both filters and maps.\n    The returned iterum yields only the values for which the supplied\n    closure returns [Some(value)][iterum.Some].\n    [filter_map][iterum.Iterum.filter_map] can be used to make chains of\n    [filter][iterum.Iterum.filter] and [map][iterum.Iterum.map] more concise.\n    Examples:\n        &gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n        ...     try:\n        ...         value = int(x)\n        ...     except ValueError:\n        ...         return nil\n        ...     else:\n        ...         return Some(value)\n        ...\n        &gt;&gt;&gt; a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"]\n        &gt;&gt;&gt; it = iterum(a).filter_map(parse2int)\n        &gt;&gt;&gt; assert it.next() == Some(1)\n        &gt;&gt;&gt; assert it.next() == Some(5)\n        &gt;&gt;&gt; assert it.next() == nil\n    \"\"\"\nreturn FilterMap(self, predicate)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.find","title":"<code>find(predicate: Callable[[T_co], object]) -&gt; Option[T_co]</code>","text":"<p>Searches for an element of an iterum that satisfies a predicate.</p> <p>find() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the iterum, and if any of them return <code>True</code>, then find() returns Some(element). If they all return <code>False</code>, it returns nil.</p> <p>find() is short-circuiting; in other words, it will stop processing as soon as the closure returns <code>True</code>.</p> <p>If you need the index of the element, see position().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; assert iterum(a).find(lambda x: x == 2) == Some(2)\n&gt;&gt;&gt; assert iterum(a).find(lambda x: x == 5) == nil\n</code></pre> <p>Stopping at the first <code>True</code>:</p> <pre><code>&gt;&gt;&gt; it = iterum([1, 2, 3])\n&gt;&gt;&gt; assert it.find(lambda x: x == 2) == Some(2)\n&gt;&gt;&gt; assert it.next() == Some(3)\n</code></pre> <p>Note that <code>it.find(f)</code> is equivalent to <code>it.filter(f).next()</code>.</p> Source code in <code>iterum/_iterum.py</code> <pre><code>def find(self, predicate: Callable[[T_co], object], /) -&gt; Option[T_co]:\n\"\"\"\n    Searches for an element of an iterum that satisfies a predicate.\n    [find()][iterum.Iterum.find] takes a closure that returns `True` or\n    `False`. It applies this closure to each element of the iterum, and if\n    any of them return `True`, then [find()][iterum.Iterum.find] returns\n    [Some(element)][iterum.Some]. If they all return `False`, it returns\n    [nil][iterum.nil].\n    [find()][iterum.Iterum.find] is short-circuiting; in other words, it\n    will stop processing as soon as the closure returns `True`.\n    If you need the index of the element, see [position()][iterum.Iterum.position].\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; assert iterum(a).find(lambda x: x == 2) == Some(2)\n        &gt;&gt;&gt; assert iterum(a).find(lambda x: x == 5) == nil\n        Stopping at the first `True`:\n        &gt;&gt;&gt; it = iterum([1, 2, 3])\n        &gt;&gt;&gt; assert it.find(lambda x: x == 2) == Some(2)\n        &gt;&gt;&gt; assert it.next() == Some(3)\n    Note that `it.find(f)` is equivalent to `it.filter(f).next()`.\n    \"\"\"\nfor x in self:\nif predicate(x):\nreturn Some(x)\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.find_map","title":"<code>find_map(predicate: Callable[[T_co], Option[U]]) -&gt; Option[U]</code>","text":"<p>Applies function to the elements of iterum and returns the first non-nil result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n...     try:\n...         value = int(x)\n...     except ValueError:\n...         return nil\n...     else:\n...         return Some(value)\n...\n&gt;&gt;&gt; a = [\"lol\", \"NaN\", \"2\", \"5\"]\n&gt;&gt;&gt; first_number = iterum(a).find_map(parse2int)\n&gt;&gt;&gt; assert first_number == Some(2)\n</code></pre> <p>Note that <code>iter.find_map(f)</code> is equivalent to <code>iter.filter_map(f).next()</code>.</p> Source code in <code>iterum/_iterum.py</code> <pre><code>def find_map(self, predicate: Callable[[T_co], Option[U]], /) -&gt; Option[U]:\n\"\"\"\n    Applies function to the elements of iterum and returns the first\n    non-nil result.\n    Examples:\n        &gt;&gt;&gt; def parse2int(x: str) -&gt; Option[int]:\n        ...     try:\n        ...         value = int(x)\n        ...     except ValueError:\n        ...         return nil\n        ...     else:\n        ...         return Some(value)\n        ...\n        &gt;&gt;&gt; a = [\"lol\", \"NaN\", \"2\", \"5\"]\n        &gt;&gt;&gt; first_number = iterum(a).find_map(parse2int)\n        &gt;&gt;&gt; assert first_number == Some(2)\n    Note that `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n    \"\"\"\nreturn self.filter_map(predicate).next()\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.flat_map","title":"<code>flat_map(f: Callable[[T_co], Iterable[U]]) -&gt; FlatMap[U]</code>","text":"<p>Creates an iterum that works like map, but flattens nested structure.</p> <p>The map adapter is very useful, but only when the closure argument produces values. If it produces an iterum instead, there\u2019s an extra layer of indirection. flat_map() will remove this extra layer on its own.</p> <p>You can think of <code>flat_map(f)</code> as the semantic equivalent of mapping, and then flattening as in <code>map(f).flatten()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n&gt;&gt;&gt; merged = iterum(words).flat_map(iterum).collect(\"\".join)\n&gt;&gt;&gt; assert merged == \"alphabetagamma\"\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def flat_map(self, f: Callable[[T_co], Iterable[U]], /) -&gt; FlatMap[U]:\n\"\"\"\n    Creates an iterum that works like map, but flattens nested structure.\n    The [map][iterum.Iterum.map] adapter is very useful, but only when the\n    closure argument produces values. If it produces an iterum instead,\n    there\u2019s an extra layer of indirection.\n    [flat_map()][iterum.Iterum.flat_map] will remove this extra layer on its own.\n    You can think of `flat_map(f)` as the semantic equivalent of mapping, and\n    then flattening as in `map(f).flatten()`.\n    Examples:\n        &gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n        &gt;&gt;&gt; merged = iterum(words).flat_map(iterum).collect(\"\".join)\n        &gt;&gt;&gt; assert merged == \"alphabetagamma\"\n    \"\"\"\nreturn FlatMap(self, f)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.flatten","title":"<code>flatten() -&gt; Flatten[U]</code>","text":"<p>Creates an iterum that flattens nested structure.</p> <p>This is useful when you have an iterum of iterables and you want to remove one level of indirection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n&gt;&gt;&gt; flattened = iterum(data).flatten().collect(list)\n&gt;&gt;&gt; assert flattened == [1, 2, 3, 4, 5, 6]\n</code></pre> <p>Mapping and then flattening:</p> <pre><code>&gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n&gt;&gt;&gt; merged = iterum(words).map(iterum).flatten().collect(\"\".join)\n&gt;&gt;&gt; assert merged == \"alphabetagamma\"\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def flatten(self: Iterum[Iterable[U]]) -&gt; Flatten[U]:\n\"\"\"\n    Creates an iterum that flattens nested structure.\n    This is useful when you have an iterum of iterables and you want to\n    remove one level of indirection.\n    Examples:\n        &gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n        &gt;&gt;&gt; flattened = iterum(data).flatten().collect(list)\n        &gt;&gt;&gt; assert flattened == [1, 2, 3, 4, 5, 6]\n        Mapping and then flattening:\n        &gt;&gt;&gt; words = [\"alpha\", \"beta\", \"gamma\"]\n        &gt;&gt;&gt; merged = iterum(words).map(iterum).flatten().collect(\"\".join)\n        &gt;&gt;&gt; assert merged == \"alphabetagamma\"\n    \"\"\"\nreturn Flatten(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.fold","title":"<code>fold(init: U, f: Callable[[U, T_co], U]) -&gt; U</code>","text":"<p>Folds every element into an accumulator by applying an operation, returning the final result.</p> <p>fold() takes two arguments: an initial value, and a closure with two arguments: an \u2018accumulator\u2019, and an element. The closure returns the value that the accumulator should have for the next iteration.</p> <p>The initial value is the value the accumulator will have on the first call.</p> <p>After applying this closure to every element of the iterum, fold() returns the accumulator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; sum = iterum(a).fold(0, lambda acc, x: acc + x)\n&gt;&gt;&gt; assert sum == 6\n</code></pre> <p>Let's walk through each step of the iteration here:</p> element acc x result 0 1 0 1 1 2 1 2 3 3 3 3 6 <p>And so, our final result, 6.</p> fold is left-associative <pre><code>&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; result = iterum(numbers).fold(\"0\", lambda acc, x: f\"({acc} + {x})\")\n&gt;&gt;&gt; assert result == \"(((((0 + 1) + 2) + 3) + 4) + 5)\"\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def fold(self, init: U, f: Callable[[U, T_co], U], /) -&gt; U:\n\"\"\"\n    Folds every element into an accumulator by applying an operation,\n    returning the final result.\n    [fold()][iterum.Iterum.fold] takes two arguments: an initial value, and\n    a closure with two arguments: an \u2018accumulator\u2019, and an element. The\n    closure returns the value that the accumulator should have for the next iteration.\n    The initial value is the value the accumulator will have on the first call.\n    After applying this closure to every element of the iterum, fold()\n    returns the accumulator.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; sum = iterum(a).fold(0, lambda acc, x: acc + x)\n        &gt;&gt;&gt; assert sum == 6\n        Let's walk through each step of the iteration here:\n        | element | acc | x | result |\n        | ------- | --- | - | ------ |\n        |         |  0  |   |        |\n        |   1     |  0  | 1 |   1    |\n        |   2     |  1  | 2 |   3    |\n        |   3     |  3  | 3 |   6    |\n        And so, our final result, 6.\n    fold is left-associative:\n        ```python\n        &gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; result = iterum(numbers).fold(\"0\", lambda acc, x: f\"({acc} + {x})\")\n        &gt;&gt;&gt; assert result == \"(((((0 + 1) + 2) + 3) + 4) + 5)\"\n        ```\n    \"\"\"\nacc = init\nfor x in self:\nacc = f(acc, x)\nreturn acc\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.for_each","title":"<code>for_each(f: Callable[[T_co], object]) -&gt; None</code>","text":"<p>Calls a closure on each element of an iterum.</p> <p>For loops are more idiomatic... but who cares!</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = []\n&gt;&gt;&gt; seq(5).map(lambda x: x * 2 + 1).for_each(v.append)\n&gt;&gt;&gt; assert v == [1, 3, 5, 7, 9]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def for_each(self, f: Callable[[T_co], object], /) -&gt; None:\n\"\"\"\n    Calls a closure on each element of an iterum.\n    For loops are more idiomatic... but who cares!\n    Examples:\n        &gt;&gt;&gt; v = []\n        &gt;&gt;&gt; seq(5).map(lambda x: x * 2 + 1).for_each(v.append)\n        &gt;&gt;&gt; assert v == [1, 3, 5, 7, 9]\n    \"\"\"\nfor x in self:\nf(x)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.fuse","title":"<code>fuse() -&gt; Fuse[T_co]</code>","text":"<p>Creates an iterum which ends after the first nil.</p> <p>After an iterum returns nil, future calls may or may not yield Some(T) again. fuse() adapts an iterum, ensuring that after a nil is given, it will always return nil forever.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Alternator(Iterator[int]):\n...     def __init__(self) -&gt; None:\n...         self.i = 0\n...     def __next__(self) -&gt; int:\n...         self.i += 1\n...         if self.i % 5:\n...             return self.i\n...         else:\n...             raise StopIteration()\n</code></pre> <pre><code>&gt;&gt;&gt; it = iterum(Alternator())\n&gt;&gt;&gt; assert list(it) == [1, 2, 3, 4]\n&gt;&gt;&gt; assert list(it) == [6, 7, 8, 9]\n&gt;&gt;&gt; assert list(it) == [11, 12, 13, 14]\n</code></pre> <pre><code>&gt;&gt;&gt; it = it.fuse()\n&gt;&gt;&gt; assert list(it) == [16, 17, 18, 19]\n&gt;&gt;&gt; assert list(it) == []\n&gt;&gt;&gt; assert list(it) == []\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def fuse(self) -&gt; Fuse[T_co]:\n\"\"\"\n    Creates an iterum which ends after the first [nil][iterum.nil].\n    After an iterum returns [nil][iterum.nil], future calls may or may not\n    yield [Some(T)][iterum.Some] again. [fuse()][iterum.Iterum.fuse] adapts\n    an iterum, ensuring that after a [nil][iterum.nil] is given, it will\n    always return [nil][iterum.nil] forever.\n    Examples:\n        &gt;&gt;&gt; class Alternator(Iterator[int]):\n        ...     def __init__(self) -&gt; None:\n        ...         self.i = 0\n        ...     def __next__(self) -&gt; int:\n        ...         self.i += 1\n        ...         if self.i % 5:\n        ...             return self.i\n        ...         else:\n        ...             raise StopIteration()\n        &gt;&gt;&gt; it = iterum(Alternator())\n        &gt;&gt;&gt; assert list(it) == [1, 2, 3, 4]\n        &gt;&gt;&gt; assert list(it) == [6, 7, 8, 9]\n        &gt;&gt;&gt; assert list(it) == [11, 12, 13, 14]\n        &gt;&gt;&gt; it = it.fuse()\n        &gt;&gt;&gt; assert list(it) == [16, 17, 18, 19]\n        &gt;&gt;&gt; assert list(it) == []\n        &gt;&gt;&gt; assert list(it) == []\n    \"\"\"\nreturn Fuse(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.ge","title":"<code>ge(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are lexicographically greater than or equal to those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1]).ge([1])\n&gt;&gt;&gt; assert not iterum([1]).ge([1, 2])\n&gt;&gt;&gt; assert iterum([1, 2]).ge([1])\n&gt;&gt;&gt; assert iterum([1, 2]).ge([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def ge(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are lexicographically\n    greater than or equal to those of another.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1]).ge([1])\n        &gt;&gt;&gt; assert not iterum([1]).ge([1, 2])\n        &gt;&gt;&gt; assert iterum([1, 2]).ge([1])\n        &gt;&gt;&gt; assert iterum([1, 2]).ge([1, 2])\n    \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp in (Ordering.Greater, Ordering.Equal)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.gt","title":"<code>gt(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are lexicographically greater than those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert not iterum([1]).gt([1])\n&gt;&gt;&gt; assert not iterum([1]).gt([1, 2])\n&gt;&gt;&gt; assert iterum([1, 2]).gt([1])\n&gt;&gt;&gt; assert not iterum([1, 2]).gt([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def gt(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are lexicographically\n    greater than those of another.\n    Examples:\n        &gt;&gt;&gt; assert not iterum([1]).gt([1])\n        &gt;&gt;&gt; assert not iterum([1]).gt([1, 2])\n        &gt;&gt;&gt; assert iterum([1, 2]).gt([1])\n        &gt;&gt;&gt; assert not iterum([1, 2]).gt([1, 2])\n    \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Greater\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.inspect","title":"<code>inspect(f: Callable[[T_co], object]) -&gt; Inspect[T_co]</code>","text":"<p>Does something with each element of an iterum, passing the value on.</p> <p>When using iterums, you\u2019ll often chain several of them together. While working on such code, you might want to check out what\u2019s happening at various parts in the pipeline. To do that, insert a call to inspect().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = (\n...    iterum([1, 4, 2, 3])\n...    .inspect(lambda x: print(f\"about to filter: {x}\"))\n...    .filter(lambda x: x % 2 == 0)\n...    .inspect(lambda x: print(f\"made it through filter: {x}\"))\n...    .fold(0, lambda sum, i: sum + i)\n... )\n...\nabout to filter: 1\nabout to filter: 4\nmade it through filter: 4\nabout to filter: 2\nmade it through filter: 2\nabout to filter: 3\n&gt;&gt;&gt; s\n6\n</code></pre> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; c = (\n...     iterum(a)\n...     .map(lambda x: x * 2)\n...     .inspect(b.append)\n...     .take_while(lambda x: x &lt; 5)\n...     .collect(list)\n... )\n&gt;&gt;&gt; assert b == [2, 4, 6]\n&gt;&gt;&gt; assert c == [2, 4]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def inspect(self, f: Callable[[T_co], object], /) -&gt; Inspect[T_co]:\n\"\"\"\n    Does something with each element of an iterum, passing the value on.\n    When using iterums, you\u2019ll often chain several of them together. While\n    working on such code, you might want to check out what\u2019s happening at\n    various parts in the pipeline. To do that, insert a call to\n    [inspect()][iterum.Iterum.inspect].\n    Examples:\n        &gt;&gt;&gt; s = (\n        ...    iterum([1, 4, 2, 3])\n        ...    .inspect(lambda x: print(f\"about to filter: {x}\"))\n        ...    .filter(lambda x: x % 2 == 0)\n        ...    .inspect(lambda x: print(f\"made it through filter: {x}\"))\n        ...    .fold(0, lambda sum, i: sum + i)\n        ... )\n        ...\n        about to filter: 1\n        about to filter: 4\n        made it through filter: 4\n        about to filter: 2\n        made it through filter: 2\n        about to filter: 3\n        &gt;&gt;&gt; s\n        6\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; b = []\n        &gt;&gt;&gt; c = (\n        ...     iterum(a)\n        ...     .map(lambda x: x * 2)\n        ...     .inspect(b.append)\n        ...     .take_while(lambda x: x &lt; 5)\n        ...     .collect(list)\n        ... )\n        &gt;&gt;&gt; assert b == [2, 4, 6]\n        &gt;&gt;&gt; assert c == [2, 4]\n    \"\"\"\nreturn Inspect(self, f)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.last","title":"<code>last() -&gt; Option[T_co]</code>","text":"<p>Consumes the iterum, returning the last element.</p> <p>This method will evaluate the iterum until it returns nil. While doing so, it keeps track of the current element. After nil is returned, last() will then return the last element it saw.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1, 2, 3]).last() == Some(3)\n&gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).last() == Some(5)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def last(self) -&gt; Option[T_co]:\n\"\"\"\n    Consumes the iterum, returning the last element.\n    This method will evaluate the iterum until it returns\n    [nil][iterum.nil]. While doing so, it keeps track of the current\n    element. After [nil][iterum.nil] is returned, last() will then return\n    the last element it saw.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1, 2, 3]).last() == Some(3)\n        &gt;&gt;&gt; assert iterum([1, 2, 3, 4, 5]).last() == Some(5)\n    \"\"\"\nlast = nil\nwhile (nxt := self.next()) is not nil:\nlast = nxt\nreturn last\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.le","title":"<code>le(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are lexicographically less or equal to those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1]).le([1])\n&gt;&gt;&gt; assert iterum([1]).le([1, 2])\n&gt;&gt;&gt; assert not iterum([1, 2]).le([1])\n&gt;&gt;&gt; assert iterum([1, 2]).le([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def le(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are lexicographically less\n    or equal to those of another.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1]).le([1])\n        &gt;&gt;&gt; assert iterum([1]).le([1, 2])\n        &gt;&gt;&gt; assert not iterum([1, 2]).le([1])\n        &gt;&gt;&gt; assert iterum([1, 2]).le([1, 2])\n    \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp in (Ordering.Less, Ordering.Equal)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.lt","title":"<code>lt(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are lexicographically less than those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert not iterum([1]).lt([1])\n&gt;&gt;&gt; assert iterum([1]).lt([1, 2])\n&gt;&gt;&gt; assert not iterum([1, 2]).lt([1])\n&gt;&gt;&gt; assert not iterum([1, 2]).lt([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def lt(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are lexicographically less\n    than those of another.\n    Examples:\n        &gt;&gt;&gt; assert not iterum([1]).lt([1])\n        &gt;&gt;&gt; assert iterum([1]).lt([1, 2])\n        &gt;&gt;&gt; assert not iterum([1, 2]).lt([1])\n        &gt;&gt;&gt; assert not iterum([1, 2]).lt([1, 2])\n    \"\"\"\ncmp = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn cmp == Ordering.Less\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.map","title":"<code>map(f: Callable[[T_co], U]) -&gt; Map[U]</code>","text":"<p>Takes a closure and creates an iterum which calls that closure on each element.</p> <p>map() transforms one iterum into another, by means of its argument. It produces a new iterum which calls this closure on each element of the original iterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; itr = iterum(a).map(lambda x: x * 2)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == Some(4)\n&gt;&gt;&gt; assert itr.next() == Some(6)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def map(self, f: Callable[[T_co], U], /) -&gt; Map[U]:\n\"\"\"\n    Takes a closure and creates an iterum which calls that closure on\n    each element.\n    [map()][iterum.Iterum.map] transforms one iterum into another, by\n    means of its argument. It produces a new iterum which calls this\n    closure on each element of the original iterum.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; itr = iterum(a).map(lambda x: x * 2)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == Some(4)\n        &gt;&gt;&gt; assert itr.next() == Some(6)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn Map(self, f)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.map_while","title":"<code>map_while(predicate: Callable[[T_co], Option[U]]) -&gt; MapWhile[U]</code>","text":"<p>Creates an iterum that both yields elements based on a predicate and maps.</p> <p>map_while() takes a closure as an argument. It will call this closure on each element of the iterum, and yield elements while it returns Some(_).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; def checked_div(num: int, dem: int) -&gt; Option[int]:\n...    try:\n...        return Some(num // dem)\n...    except ZeroDivisionError:\n...        return nil\n...\n&gt;&gt;&gt; a = [-1, 4, 0, 1]\n&gt;&gt;&gt; it = iterum(a).map_while(partial(checked_div, 16))\n&gt;&gt;&gt; assert it.next() == Some(-16)\n&gt;&gt;&gt; assert it.next() == Some(4)\n&gt;&gt;&gt; assert it.next() == nil\n</code></pre> <p>Stops after first nil:</p> <pre><code>&gt;&gt;&gt; a = [0, 1, 2, -3, 4, 5, -6]\n&gt;&gt;&gt; it = iterum(a).map_while(lambda x: Some(x) if x &gt;= 0 else nil)\n&gt;&gt;&gt; vec = it.collect(list)\n&gt;&gt;&gt; assert vec == [0, 1, 2]\n&gt;&gt;&gt; assert it.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def map_while(self, predicate: Callable[[T_co], Option[U]], /) -&gt; MapWhile[U]:\n\"\"\"\n    Creates an iterum that both yields elements based on a predicate and maps.\n    [map_while()][iterum.Iterum.map_while] takes a closure as an argument.\n    It will call this closure on each element of the iterum, and yield\n    elements while it returns [Some(_)][iterum.Some].\n    Examples:\n        &gt;&gt;&gt; from functools import partial\n        &gt;&gt;&gt; def checked_div(num: int, dem: int) -&gt; Option[int]:\n        ...    try:\n        ...        return Some(num // dem)\n        ...    except ZeroDivisionError:\n        ...        return nil\n        ...\n        &gt;&gt;&gt; a = [-1, 4, 0, 1]\n        &gt;&gt;&gt; it = iterum(a).map_while(partial(checked_div, 16))\n        &gt;&gt;&gt; assert it.next() == Some(-16)\n        &gt;&gt;&gt; assert it.next() == Some(4)\n        &gt;&gt;&gt; assert it.next() == nil\n        Stops after first [nil][iterum.nil]:\n        &gt;&gt;&gt; a = [0, 1, 2, -3, 4, 5, -6]\n        &gt;&gt;&gt; it = iterum(a).map_while(lambda x: Some(x) if x &gt;= 0 else nil)\n        &gt;&gt;&gt; vec = it.collect(list)\n        &gt;&gt;&gt; assert vec == [0, 1, 2]\n        &gt;&gt;&gt; assert it.next() == nil\n    \"\"\"\nreturn MapWhile(self, predicate)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.max","title":"<code>max() -&gt; Option[SupportsRichComparisonT]</code>","text":"<p>Returns the maximum element of an iterum.</p> <p>If several elements are equally maximum, the last element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1, 2, 3]).max() == Some(3)\n&gt;&gt;&gt; assert iterum([]).max() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def max(\nself: Iterum[SupportsRichComparisonT],\n) -&gt; Option[SupportsRichComparisonT]:\n\"\"\"\n    Returns the maximum element of an iterum.\n    If several elements are equally maximum, the last element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1, 2, 3]).max() == Some(3)\n        &gt;&gt;&gt; assert iterum([]).max() == nil\n    \"\"\"\ntry:\nreturn Some(builtins.max(self))\nexcept ValueError:\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.max_by","title":"<code>max_by(compare: Callable[[T_co, T_co], Ordering]) -&gt; Option[T_co]</code>","text":"<p>Returns the element that gives the maximum value with respect to the specified comparison function.</p> <p>If several elements are equally maximum, the last element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n&gt;&gt;&gt; assert iterum(a).max_by(Ordering.cmp).unwrap() == 5\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def max_by(self, compare: Callable[[T_co, T_co], Ordering], /) -&gt; Option[T_co]:\n\"\"\"\n    Returns the element that gives the maximum value with respect to the\n    specified comparison function.\n    If several elements are equally maximum, the last element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n        &gt;&gt;&gt; assert iterum(a).max_by(Ordering.cmp).unwrap() == 5\n    \"\"\"\nmax_ = self.next()\nif max_ is nil:\nreturn nil\nelse:\nmax_ = max_.unwrap()\nfor nxt in self:\nif compare(max_, nxt) is Ordering.Less:\nmax_ = nxt\nreturn Some(max_)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.max_by_key","title":"<code>max_by_key(f: Callable[[T_co], SupportsRichComparison]) -&gt; Option[T_co]</code>","text":"<p>Returns the element that gives the maximum value from the specified function.</p> <p>If several elements are equally maximum, the last element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n&gt;&gt;&gt; assert iterum(a).max_by_key(abs).unwrap() == -10\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def max_by_key(\nself, f: Callable[[T_co], SupportsRichComparison], /\n) -&gt; Option[T_co]:\n\"\"\"\n    Returns the element that gives the maximum value from the specified function.\n    If several elements are equally maximum, the last element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n        &gt;&gt;&gt; assert iterum(a).max_by_key(abs).unwrap() == -10\n    \"\"\"\ndef compare(x, y) -&gt; Ordering:\nfx = f(x)\nfy = f(y)\nreturn Ordering.cmp(fx, fy)\nreturn self.max_by(compare)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.min","title":"<code>min() -&gt; Option[SupportsRichComparisonT]</code>","text":"<p>Returns the minimum element of an iterum.</p> <p>If several elements are equally minimum, the first element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1, 2, 3]).min() == Some(1)\n&gt;&gt;&gt; assert iterum([]).min() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def min(\nself: Iterum[SupportsRichComparisonT],\n) -&gt; Option[SupportsRichComparisonT]:\n\"\"\"\n    Returns the minimum element of an iterum.\n    If several elements are equally minimum, the first element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1, 2, 3]).min() == Some(1)\n        &gt;&gt;&gt; assert iterum([]).min() == nil\n    \"\"\"\ntry:\nreturn Some(builtins.min(self))\nexcept ValueError:\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.min_by","title":"<code>min_by(compare: Callable[[T_co, T_co], Ordering]) -&gt; Option[T_co]</code>","text":"<p>Returns the element that gives the minimum value with respect to the specified comparison function.</p> <p>If several elements are equally minimum, the first element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n&gt;&gt;&gt; assert iterum(a).min_by(Ordering.cmp).unwrap() == -10\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def min_by(self, compare: Callable[[T_co, T_co], Ordering], /) -&gt; Option[T_co]:\n\"\"\"\n    Returns the element that gives the minimum value with respect to the\n    specified comparison function.\n    If several elements are equally minimum, the first element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n        &gt;&gt;&gt; assert iterum(a).min_by(Ordering.cmp).unwrap() == -10\n    \"\"\"\nmin_ = self.next()\nif min_ is nil:\nreturn nil\nelse:\nmin_ = min_.unwrap()\nfor nxt in self:\nif compare(min_, nxt) is Ordering.Greater:\nmin_ = nxt\nreturn Some(min_)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.min_by_key","title":"<code>min_by_key(f: Callable[[T_co], SupportsRichComparison]) -&gt; Option[T_co]</code>","text":"<p>Returns the element that gives the minimum value from the specified function.</p> <p>If several elements are equally minimum, the first element is returned. If the iterum is empty, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n&gt;&gt;&gt; assert iterum(a).min_by_key(abs).unwrap() == 0\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def min_by_key(\nself, f: Callable[[T_co], SupportsRichComparison], /\n) -&gt; Option[T_co]:\n\"\"\"\n    Returns the element that gives the minimum value from the specified function.\n    If several elements are equally minimum, the first element is returned.\n    If the iterum is empty, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; a = [-3, 0, 1, 5, -10]\n        &gt;&gt;&gt; assert iterum(a).min_by_key(abs).unwrap() == 0\n    \"\"\"\ndef compare(x, y) -&gt; Ordering:\nfx = f(x)\nfy = f(y)\nreturn Ordering.cmp(fx, fy)\nreturn self.min_by(compare)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.ne","title":"<code>ne(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; bool</code>","text":"<p>Determines if the elements of this Iterator are not equal to those of another.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert not iterum([1]).ne([1])\n&gt;&gt;&gt; assert iterum([1]).ne([1, 2])\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def ne(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; bool:\n\"\"\"\n    Determines if the elements of this Iterator are not equal to those of another.\n    Examples:\n        &gt;&gt;&gt; assert not iterum([1]).ne([1])\n        &gt;&gt;&gt; assert iterum([1]).ne([1, 2])\n    \"\"\"\neq = self.eq(other)  # type: ignore | reason: ask for forgiveness not permission\nreturn not eq\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.nth","title":"<code>nth(n: int) -&gt; Option[T_co]</code>","text":"<p>Returns the nth element of the iterum.</p> <p>Like most indexing operations, the count starts from zero, so nth(0) returns the first value, nth(1) the second, and so on.</p> <p>Note that all preceding elements, as well as the returned element, will be consumed from the iterum. That means that the preceding elements will be discarded, and also that calling nth(0) multiple times on the same iterum will return different elements.</p> <p>nth() will return nil if n is greater than or equal to the length of the iterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; assert iterum(a).nth(1) == Some(2)\n</code></pre> <p>Calling nth multiple times doesn't rewind the iterum:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3])\n&gt;&gt;&gt; assert itr.nth(1) == Some(2)\n&gt;&gt;&gt; assert itr.nth(1) == nil\n</code></pre> <p>Returns nil if there are less than <code>n + 1</code> elements:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3])\n&gt;&gt;&gt; assert itr.nth(3) == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def nth(self, n: int, /) -&gt; Option[T_co]:\n\"\"\"\n    Returns the nth element of the iterum.\n    Like most indexing operations, the count starts from zero, so [nth(0)][iterum.Iterum.nth]\n    returns the first value, [nth(1)][iterum.Iterum.nth] the second, and so on.\n    Note that all preceding elements, as well as the returned element, will\n    be consumed from the iterum. That means that the preceding elements\n    will be discarded, and also that calling [nth(0)][iterum.Iterum.nth] multiple times on the\n    same iterum will return different elements.\n    [nth()][iterum.Iterum.nth] will return [nil][iterum.nil] if n is greater\n    than or equal to the length of the iterum.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; assert iterum(a).nth(1) == Some(2)\n        Calling [nth][iterum.Iterum.nth] multiple times doesn't rewind the iterum:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3])\n        &gt;&gt;&gt; assert itr.nth(1) == Some(2)\n        &gt;&gt;&gt; assert itr.nth(1) == nil\n        Returns [nil][iterum.nil] if there are less than `n + 1` elements:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3])\n        &gt;&gt;&gt; assert itr.nth(3) == nil\n    \"\"\"\nfor i, x in enumerate(self):\nif i &gt; n:\nreturn nil\nif i == n:\nreturn Some(x)\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.partial_cmp","title":"<code>partial_cmp(other: Iterable[object] | Iterable[SupportsRichComparison]) -&gt; Option[Ordering]</code>","text":"<p>Lexicographically compares the PartialOrd elements of this Iterator with those of another. The comparison works like short-circuit evaluation, returning a result without comparing the remaining elements. As soon as an order can be determined, the evaluation stops and a result is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert iterum([1]).partial_cmp([1]) == Some(Ordering.Equal)\n&gt;&gt;&gt; assert iterum([1, 2]).partial_cmp([1]) == Some(Ordering.Greater)\n&gt;&gt;&gt; assert iterum([1]).partial_cmp([1, 2]) == Some(Ordering.Less)\n</code></pre> <p>Results are determined by the order of evaluation:</p> <pre><code>&gt;&gt;&gt; assert iterum([1, None]).partial_cmp([2, nil]) == Some(Ordering.Less)\n&gt;&gt;&gt; assert iterum([2, None]).partial_cmp([1, nil]) == Some(Ordering.Greater)\n&gt;&gt;&gt; assert iterum([None, 1]).partial_cmp([2, None]) == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def partial_cmp(\nself: Iterum[SupportsRichComparison] | Iterum[object],\nother: Iterable[object] | Iterable[SupportsRichComparison],\n/,\n) -&gt; Option[Ordering]:\n\"\"\"\n    Lexicographically compares the PartialOrd elements of this Iterator with\n    those of another. The comparison works like short-circuit evaluation,\n    returning a result without comparing the remaining elements. As soon as\n    an order can be determined, the evaluation stops and a result is returned.\n    Examples:\n        &gt;&gt;&gt; assert iterum([1]).partial_cmp([1]) == Some(Ordering.Equal)\n        &gt;&gt;&gt; assert iterum([1, 2]).partial_cmp([1]) == Some(Ordering.Greater)\n        &gt;&gt;&gt; assert iterum([1]).partial_cmp([1, 2]) == Some(Ordering.Less)\n        Results are determined by the order of evaluation:\n        &gt;&gt;&gt; assert iterum([1, None]).partial_cmp([2, nil]) == Some(Ordering.Less)\n        &gt;&gt;&gt; assert iterum([2, None]).partial_cmp([1, nil]) == Some(Ordering.Greater)\n        &gt;&gt;&gt; assert iterum([None, 1]).partial_cmp([2, None]) == nil\n    \"\"\"\ntry:\nvalue = self.cmp(other)  # type: ignore | reason: ask for forgiveness not permission\nexcept TypeError:\nreturn nil\nelse:\nreturn Some(value)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.partition","title":"<code>partition(f: Callable[[T_co], object], container: Callable[[Iterable[T_co]], U] = list) -&gt; tuple[U, U]</code>","text":"<p>Consumes an iterum, creating two collections from it.</p> <p>The predicate passed to partition() can return <code>True</code>, or <code>False</code>. partition() returns a pair, all of the elements for which it returned <code>True</code>, and all of the elements for which it returned <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; even, odd = iterum(a).partition(lambda n: n % 2 == 0)\n&gt;&gt;&gt; assert even == [2]\n&gt;&gt;&gt; assert odd == [1, 3]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def partition(  # type: ignore\nself,\nf: Callable[[T_co], object],\ncontainer: Callable[[Iterable[T_co]], U] = list,\n/,\n) -&gt; tuple[U, U]:\n\"\"\"\n    Consumes an iterum, creating two collections from it.\n    The predicate passed to [partition()][iterum.Iterum.partition] can\n    return `True`, or `False`. [partition()][iterum.Iterum.partition]\n    returns a pair, all of the elements for which it returned `True`, and\n    all of the elements for which it returned `False`.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; even, odd = iterum(a).partition(lambda n: n % 2 == 0)\n        &gt;&gt;&gt; assert even == [2]\n        &gt;&gt;&gt; assert odd == [1, 3]\n    \"\"\"\nmatches, notmatches = [], []\nfor x in self:\nmatches.append(x) if f(x) else notmatches.append(x)\nreturn container(matches), container(notmatches)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.peekable","title":"<code>peekable() -&gt; Peekable[T_co]</code>","text":"<p>Creates an iterum which provides a peek attribute for viewing and setting the next element of the iterum without consuming it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xs = [1, 2, 3]\n&gt;&gt;&gt; itr = iterum(xs).peekable()\n&gt;&gt;&gt; assert itr.peek == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.peek == Some(3)\n&gt;&gt;&gt; assert itr.peek == Some(3)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n&gt;&gt;&gt; assert itr.peek == nil\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <pre><code>&gt;&gt;&gt; xs = [1, 2, 3]\n&gt;&gt;&gt; itr = iterum(xs).peekable()\n&gt;&gt;&gt; assert itr.peek == Some(1)\n&gt;&gt;&gt; assert itr.peek == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.peek == Some(2)\n&gt;&gt;&gt; itr.peek = 1000\n&gt;&gt;&gt; assert list(itr) == [1000, 3]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def peekable(self) -&gt; Peekable[T_co]:\n\"\"\"\n    Creates an iterum which provides a peek attribute for viewing\n    and setting the next element of the iterum without consuming it.\n    Examples:\n        &gt;&gt;&gt; xs = [1, 2, 3]\n        &gt;&gt;&gt; itr = iterum(xs).peekable()\n        &gt;&gt;&gt; assert itr.peek == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.peek == Some(3)\n        &gt;&gt;&gt; assert itr.peek == Some(3)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n        &gt;&gt;&gt; assert itr.peek == nil\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; xs = [1, 2, 3]\n        &gt;&gt;&gt; itr = iterum(xs).peekable()\n        &gt;&gt;&gt; assert itr.peek == Some(1)\n        &gt;&gt;&gt; assert itr.peek == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.peek == Some(2)\n        &gt;&gt;&gt; itr.peek = 1000\n        &gt;&gt;&gt; assert list(itr) == [1000, 3]\n    \"\"\"\nreturn Peekable(self)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.position","title":"<code>position(predicate: Callable[[T_co], object]) -&gt; Option[int]</code>","text":"<p>Searches for an element in an iterum, returning its index.</p> <p>position() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the iterum, and if one of them returns <code>True</code>, then position() returns Some(index). If all of them return <code>False</code>, it returns nil.</p> <p>position() is short-circuiting; in other words, it will stop processing as soon as it finds a <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; assert iterum(a).position(lambda x: x == 2) == Some(1)\n&gt;&gt;&gt; assert iterum(a).position(lambda x: x == 5) == nil\n</code></pre> <pre><code>&gt;&gt;&gt; it = iterum([1, 2, 3, 4])\n&gt;&gt;&gt; assert it.position(lambda x: x &gt;= 2) == Some(1)\n&gt;&gt;&gt; assert it.next() == Some(3)\n&gt;&gt;&gt; assert it.position(lambda x: x == 4) == Some(0)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def position(self, predicate: Callable[[T_co], object], /) -&gt; Option[int]:\n\"\"\"\n    Searches for an element in an iterum, returning its index.\n    [position()][iterum.Iterum.position] takes a closure that returns `True`\n    or `False`. It applies this closure to each element of the iterum, and\n    if one of them returns `True`, then [position()][iterum.Iterum.position]\n    returns [Some(index)][iterum.Some]. If all of them return `False`, it\n    returns [nil][iterum.nil].\n    [position()][iterum.Iterum.position] is short-circuiting; in other\n    words, it will stop processing as soon as it finds a `True`.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; assert iterum(a).position(lambda x: x == 2) == Some(1)\n        &gt;&gt;&gt; assert iterum(a).position(lambda x: x == 5) == nil\n        &gt;&gt;&gt; it = iterum([1, 2, 3, 4])\n        &gt;&gt;&gt; assert it.position(lambda x: x &gt;= 2) == Some(1)\n        &gt;&gt;&gt; assert it.next() == Some(3)\n        &gt;&gt;&gt; assert it.position(lambda x: x == 4) == Some(0)\n    \"\"\"\nfor i, x in enumerate(self):\nif predicate(x):\nreturn Some(i)\nreturn nil\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.product","title":"<code>product() -&gt; Option[SupportsMulT]</code>","text":"<p>Iterates over the entire iterum, multiplying all the elements</p> <p>An empty iterum returns nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def factorial(n: int) -&gt; int:\n...     return seq(1, n + 1).product().unwrap_or(1)\n...\n&gt;&gt;&gt; assert factorial(0) == 1\n&gt;&gt;&gt; assert factorial(1) == 1\n&gt;&gt;&gt; assert factorial(5) == 120\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def product(self: Iterum[SupportsMulT]) -&gt; Option[SupportsMulT]:\n\"\"\"\n    Iterates over the entire iterum, multiplying all the elements\n    An empty iterum returns [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; def factorial(n: int) -&gt; int:\n        ...     return seq(1, n + 1).product().unwrap_or(1)\n        ...\n        &gt;&gt;&gt; assert factorial(0) == 1\n        &gt;&gt;&gt; assert factorial(1) == 1\n        &gt;&gt;&gt; assert factorial(5) == 120\n    \"\"\"\nreturn self.reduce(lambda acc, x: acc * x)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.reduce","title":"<code>reduce(f: Callable[[T_co, T_co], T_co]) -&gt; Option[T_co]</code>","text":"<p>Reduces the elements to a single one, by repeatedly applying a reducing operation.</p> <p>If the iterum is empty, returns nil; otherwise, returns the result of the reduction.</p> <p>The reducing function is a closure with two arguments: an \u2018accumulator\u2019, and an element. For iterums with at least one element, this is the same as fold() with the first element of the iterum as the initial accumulator value, folding every subsequent element into it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; reduced = seq(1, 10).reduce(lambda acc, e: acc + e).unwrap()\n&gt;&gt;&gt; assert reduced == 45\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def reduce(self, f: Callable[[T_co, T_co], T_co], /) -&gt; Option[T_co]:\n\"\"\"\n    Reduces the elements to a single one, by repeatedly applying a reducing operation.\n    If the iterum is empty, returns [nil][iterum.nil]; otherwise, returns\n    the result of the reduction.\n    The reducing function is a closure with two arguments: an \u2018accumulator\u2019,\n    and an element. For iterums with at least one element, this is the\n    same as [fold()][iterum.Iterum.fold] with the first element of the\n    iterum as the initial accumulator value, folding every subsequent\n    element into it.\n    Examples:\n        &gt;&gt;&gt; reduced = seq(1, 10).reduce(lambda acc, e: acc + e).unwrap()\n        &gt;&gt;&gt; assert reduced == 45\n    \"\"\"\nfirst = self.next()\nif first is nil:\nreturn nil\nelse:\nreturn Some(self.fold(first.unwrap(), f))\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.scan","title":"<code>scan(init: U, f: Callable[[State[U], T_co], Option[V]]) -&gt; Scan[V]</code>","text":"<p>An iterum adapter which, like fold, holds internal state, but unlike fold, produces a new iterum.</p> <p>scan() takes two arguments: an initial value which seeds the internal state, and a closure with two arguments, the first being the internal state and the second an iterum element. The closure can assign to the internal state to share state between iterations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3, 4])\n&gt;&gt;&gt; def scanner(state: State, x: int) -&gt; Option[int]:\n...     state.value *= x\n...     if state.value &gt; 6:\n...         return nil\n...     return Some(-state.value)\n...\n&gt;&gt;&gt; scan = itr.scan(1, scanner)\n&gt;&gt;&gt; assert scan.next() == Some(-1)\n&gt;&gt;&gt; assert scan.next() == Some(-2)\n&gt;&gt;&gt; assert scan.next() == Some(-6)\n&gt;&gt;&gt; assert scan.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def scan(self, init: U, f: Callable[[State[U], T_co], Option[V]], /) -&gt; Scan[V]:\n\"\"\"\n    An iterum adapter which, like fold, holds internal state, but unlike\n    fold, produces a new iterum.\n    [scan()][iterum.Iterum.scan] takes two arguments: an initial value which\n    seeds the internal state, and a closure with two arguments, the first\n    being the internal state and the second an iterum element.\n    The closure can assign to the internal state to share state between iterations.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3, 4])\n        &gt;&gt;&gt; def scanner(state: State, x: int) -&gt; Option[int]:\n        ...     state.value *= x\n        ...     if state.value &gt; 6:\n        ...         return nil\n        ...     return Some(-state.value)\n        ...\n        &gt;&gt;&gt; scan = itr.scan(1, scanner)\n        &gt;&gt;&gt; assert scan.next() == Some(-1)\n        &gt;&gt;&gt; assert scan.next() == Some(-2)\n        &gt;&gt;&gt; assert scan.next() == Some(-6)\n        &gt;&gt;&gt; assert scan.next() == nil\n    \"\"\"\nreturn Scan(self, init, f)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.skip","title":"<code>skip(n: int) -&gt; Skip[T_co]</code>","text":"<p>Creates an iterum that skips the first n elements.</p> <p>skip(n) skips elements until n elements are skipped or the end of the iterum is reached (whichever happens first). After that, all the remaining elements are yielded. In particular, if the original iterum is too short, then the returned iterum is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(2)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Skipping past end:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(10)\n&gt;&gt;&gt; assert itr.next() == nil\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def skip(self, n: int, /) -&gt; Skip[T_co]:\n\"\"\"\n    Creates an iterum that skips the first n elements.\n    [skip(n)][iterum.Iterum.skip] skips elements until n elements are\n    skipped or the end of the iterum is reached (whichever happens first).\n    After that, all the remaining elements are yielded. In particular, if\n    the original iterum is too short, then the returned iterum is empty.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(2)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n        &gt;&gt;&gt; assert itr.next() == nil\n        Skipping past end:\n        &gt;&gt;&gt; itr = iterum([1, 2, 3]).skip(10)\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn Skip(self, n)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.skip_while","title":"<code>skip_while(predicate: Callable[[T_co], object]) -&gt; SkipWhile[T_co]</code>","text":"<p>Creates an iterum that skips elements based on a predicate.</p> <p>skip_while() takes a closure as an argument. It will call this closure on each element of the iterum, and ignore elements until it returns <code>False</code>.</p> <p>After <code>False</code> is returned, skip_while()\u2019s job is over, and the rest of the elements are yielded.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([-1, 0, 1]).skip_while(lambda x: x &lt; 0)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>After first <code>False</code> condition is hit, no further elements are checked:</p> <pre><code>&gt;&gt;&gt; itr = iterum([-1, 0, 1, -3]).skip_while(lambda x: x &lt; 0)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(-3)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def skip_while(self, predicate: Callable[[T_co], object], /) -&gt; SkipWhile[T_co]:\n\"\"\"\n    Creates an iterum that skips elements based on a predicate.\n    [skip_while()][iterum.Iterum.skip_while] takes a closure as an argument.\n    It will call this closure on each element of the iterum, and ignore\n    elements until it returns `False`.\n    After `False` is returned, [skip_while()][iterum.Iterum.skip_while]\u2019s\n    job is over, and the rest of the elements are yielded.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([-1, 0, 1]).skip_while(lambda x: x &lt; 0)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == nil\n        After first `False` condition is hit, no further elements are checked:\n        &gt;&gt;&gt; itr = iterum([-1, 0, 1, -3]).skip_while(lambda x: x &lt; 0)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(-3)\n    \"\"\"\nreturn SkipWhile(self, predicate)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.step_by","title":"<code>step_by(step: int) -&gt; StepBy[T_co]</code>","text":"<p>Creates an iterum starting at the same point, but stepping by the given amount at each iteration. This always includes the first element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = iterum([0, 1, 2, 3, 4, 5]).step_by(2)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == Some(4)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def step_by(self, step: int, /) -&gt; StepBy[T_co]:\n\"\"\"\n    Creates an iterum starting at the same point, but stepping by the\n    given amount at each iteration. This always includes the first element.\n    Examples:\n        &gt;&gt;&gt; itr = iterum([0, 1, 2, 3, 4, 5]).step_by(2)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == Some(4)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn StepBy(self, step)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.sum","title":"<code>sum() -&gt; Option[SupportsSumNoDefaultT]</code>","text":"<p>Sums the elements of an iterum.</p> <p>Takes each element, adds them together, and returns the result.</p> <p>An empty iterum returns nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; sum_ = iterum(a).sum().unwrap_or(0)\n&gt;&gt;&gt; assert sum_ == 6\n</code></pre> <pre><code>&gt;&gt;&gt; sum_ = iterum([]).sum().unwrap_or(0)\n&gt;&gt;&gt; assert sum_ == 0\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def sum(self: Iterum[SupportsSumNoDefaultT]) -&gt; Option[SupportsSumNoDefaultT]:\n\"\"\"\n    Sums the elements of an iterum.\n    Takes each element, adds them together, and returns the result.\n    An empty iterum returns [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; sum_ = iterum(a).sum().unwrap_or(0)\n        &gt;&gt;&gt; assert sum_ == 6\n        &gt;&gt;&gt; sum_ = iterum([]).sum().unwrap_or(0)\n        &gt;&gt;&gt; assert sum_ == 0\n    \"\"\"\n# NOTE: This forces users to pick a default or suffer the unwrapping consequences\n# a more reasonable interface since an implicit default isn't a thing\nfirst = self.next()\nif first is nil:\nreturn nil\nreturn Some(sum(self, start=first.unwrap()))\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.take","title":"<code>take(n: int) -&gt; Take[T_co]</code>","text":"<p>Creates an iterum that yields the first n elements, or fewer if the underlying iterum ends sooner.</p> <p>take(n) yields elements until n elements are yielded or the end of the iterum is reached (whichever happens first). The returned iterum is a prefix of length n if the original iterum contains at least n elements, otherwise it contains all of the (fewer than n) elements of the original iterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; itr = iterum(a).take(2)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; itr = iterum(a).take(2)\n&gt;&gt;&gt; assert list(itr) == [1, 2]\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Truncate an infinite iterum:</p> <pre><code>&gt;&gt;&gt; itr = seq(...).take(3)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Taking more than you have:</p> <pre><code>&gt;&gt;&gt; itr = iterum([1, 2]).take(5)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def take(self, n: int, /) -&gt; Take[T_co]:\n\"\"\"\n    Creates an iterum that yields the first n elements, or fewer if the\n    underlying iterum ends sooner.\n    [take(n)][iterum.Iterum.take] yields elements until n elements are\n    yielded or the end of the iterum is reached (whichever happens first).\n    The returned iterum is a prefix of length n if the original iterum\n    contains at least n elements, otherwise it contains all of the (fewer\n    than n) elements of the original iterum.\n    Examples:\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; itr = iterum(a).take(2)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; itr = iterum(a).take(2)\n        &gt;&gt;&gt; assert list(itr) == [1, 2]\n        &gt;&gt;&gt; assert itr.next() == nil\n        Truncate an infinite iterum:\n        &gt;&gt;&gt; itr = seq(...).take(3)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n        Taking more than you have:\n        &gt;&gt;&gt; itr = iterum([1, 2]).take(5)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn Take(self, n)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.take_while","title":"<code>take_while(predicate: Callable[[T_co], object]) -&gt; TakeWhile[T_co]</code>","text":"<p>Creates an iterum that yields elements based on a predicate.</p> <p>take_while() takes a closure as an argument. It will call this closure on each element of the iterum, and yield elements while it returns <code>True</code>.</p> <p>After <code>False</code> is returned, take_while()\u2019s job is over, and the rest of the elements are ignored.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [-1, 0, 1]\n&gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n&gt;&gt;&gt; assert itr.next() == Some(-1)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Stop after first <code>False</code>:</p> <pre><code>&gt;&gt;&gt; a = [-1, 0, 1, -2]\n&gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n&gt;&gt;&gt; assert itr.next() == Some(-1)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def take_while(self, predicate: Callable[[T_co], object], /) -&gt; TakeWhile[T_co]:\n\"\"\"\n    Creates an iterum that yields elements based on a predicate.\n    [take_while()][iterum.Iterum.take_while] takes a closure as an argument.\n    It will call this closure on each element of the iterum, and yield\n    elements while it returns `True`.\n    After `False` is returned, [take_while()][iterum.Iterum.take_while]\u2019s\n    job is over, and the rest of the elements are ignored.\n    Examples:\n        &gt;&gt;&gt; a = [-1, 0, 1]\n        &gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n        &gt;&gt;&gt; assert itr.next() == Some(-1)\n        &gt;&gt;&gt; assert itr.next() == nil\n        Stop after first `False`:\n        &gt;&gt;&gt; a = [-1, 0, 1, -2]\n        &gt;&gt;&gt; itr = iterum(a).take_while(lambda x: x &lt; 0)\n        &gt;&gt;&gt; assert itr.next() == Some(-1)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nreturn TakeWhile(self, predicate)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.try_fold","title":"<code>try_fold(init: U, f: Callable[[U, T_co], U], /, *, exception: type[BaseException] | tuple[type[BaseException], ...] = Exception) -&gt; Option[U]</code>","text":"<p>An iterum method that applies a function as long as it returns successfully, producing a single, final value.</p> <p>try_fold() takes two arguments: an initial value, and a closure with two arguments: an \u2018accumulator\u2019, and an element. The closure either returns successfully, with the value that the accumulator should have for the next iteration, or it raises an exception which short-circuits the iteration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def checked_add_i8(lhs: int, rhs: int) -&gt; int:\n...     value = lhs + rhs\n...     if -128 &lt;= value &lt;= 127:\n...         return value\n...     else:\n...         raise ValueError(\"Overflow!\")\n...\n&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; sum = iterum(a).try_fold(0, checked_add_i8)\n&gt;&gt;&gt; assert sum == Some(6)\n</code></pre> <p>short-circuit after a failure:</p> <pre><code>&gt;&gt;&gt; it = iterum([10, 20, 30, 100, 40, 50])\n&gt;&gt;&gt; sum = it.try_fold(0, checked_add_i8)\n&gt;&gt;&gt; assert sum == nil\n&gt;&gt;&gt; assert list(it) == [40, 50]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def try_fold(\nself,\ninit: U,\nf: Callable[[U, T_co], U],\n/,\n*,\nexception: type[BaseException] | tuple[type[BaseException], ...] = Exception,\n) -&gt; Option[U]:\n\"\"\"\n    An iterum method that applies a function as long as it returns\n    successfully, producing a single, final value.\n    [try_fold()][iterum.Iterum.try_fold] takes two arguments: an initial\n    value, and a closure with two arguments: an \u2018accumulator\u2019, and an\n    element. The closure either returns successfully, with the value that\n    the accumulator should have for the next iteration, or it raises an\n    exception which short-circuits the iteration.\n    Examples:\n        &gt;&gt;&gt; def checked_add_i8(lhs: int, rhs: int) -&gt; int:\n        ...     value = lhs + rhs\n        ...     if -128 &lt;= value &lt;= 127:\n        ...         return value\n        ...     else:\n        ...         raise ValueError(\"Overflow!\")\n        ...\n        &gt;&gt;&gt; a = [1, 2, 3]\n        &gt;&gt;&gt; sum = iterum(a).try_fold(0, checked_add_i8)\n        &gt;&gt;&gt; assert sum == Some(6)\n        short-circuit after a failure:\n        &gt;&gt;&gt; it = iterum([10, 20, 30, 100, 40, 50])\n        &gt;&gt;&gt; sum = it.try_fold(0, checked_add_i8)\n        &gt;&gt;&gt; assert sum == nil\n        &gt;&gt;&gt; assert list(it) == [40, 50]\n    \"\"\"\nacc = init\nfor x in self:\ntry:\nacc = f(acc, x)\nexcept exception:\nreturn nil\nreturn Some(acc)\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.unzip","title":"<code>unzip(container: Callable[[Iterable[object]], U] = list) -&gt; tuple[U, U]</code>","text":"<p>Converts an iterum of pairs into a pair of containers.</p> <p>unzip() consumes an entire iterum of pairs, producing two collections: one from the left elements of the pairs, and one from the right elements.</p> <p>This function is, in some sense, the opposite of zip.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [(1, 2), (3, 4), (5, 6)]\n&gt;&gt;&gt; left, right = iterum(a).unzip()\n&gt;&gt;&gt; assert left == [1, 3, 5]\n&gt;&gt;&gt; assert right == [2, 4, 6]\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def unzip(\nself: Iterum[tuple[object, object]],\ncontainer: Callable[[Iterable[object]], U] = list,\n/,\n) -&gt; tuple[U, U]:\n\"\"\"\n    Converts an iterum of pairs into a pair of containers.\n    [unzip()][iterum.Iterum.unzip] consumes an entire iterum of pairs,\n    producing two collections: one from the left elements of the pairs, and\n    one from the right elements.\n    This function is, in some sense, the opposite of [zip][iterum.Iterum.zip].\n    Examples:\n        &gt;&gt;&gt; a = [(1, 2), (3, 4), (5, 6)]\n        &gt;&gt;&gt; left, right = iterum(a).unzip()\n        &gt;&gt;&gt; assert left == [1, 3, 5]\n        &gt;&gt;&gt; assert right == [2, 4, 6]\n    \"\"\"\nleft, right = map(container, zip(*self))\nreturn left, right\n</code></pre>"},{"location":"api/#iterum._iterum.Iterum.zip","title":"<code>zip(other: Iterable[U]) -&gt; Zip[T_co, U]</code>","text":"<p>\u2018Zips up\u2019 two iterables into a single iterum of pairs.</p> <p>zip() returns a new iterum that will iterate over two other iterables, returning a tuple where the first element comes from the first iterable, and the second element comes from the second iterable.</p> <p>If either iterable returns nil, next from the zipped iterum will return nil. If the zipped iterum has no more elements to return then each further attempt to advance it will first try to advance the first iterable at most one time and if it still yielded an item try to advance the second iterable at most one time.</p> <p>To \u2018undo\u2019 the result of zipping up two iterables, see unzip.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a1 = [1, 2, 3]\n&gt;&gt;&gt; a2 = [4, 5, 6]\n&gt;&gt;&gt; itr = iterum(a1).zip(a2)\n&gt;&gt;&gt; assert itr.next() == Some((1, 4))\n&gt;&gt;&gt; assert itr.next() == Some((2, 5))\n&gt;&gt;&gt; assert itr.next() == Some((3, 6))\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>zip smaller with larger:</p> <pre><code>&gt;&gt;&gt; inf_itr = seq(...)\n&gt;&gt;&gt; foo_itr = iterum(\"foo\")\n&gt;&gt;&gt; zip_itr = foo_itr.zip(inf_itr)\n&gt;&gt;&gt; assert zip_itr.next() == Some((\"f\", 0))\n&gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 1))\n&gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 2))\n&gt;&gt;&gt; assert zip_itr.next() == nil\n&gt;&gt;&gt; assert foo_itr.next() == nil\n&gt;&gt;&gt; assert inf_itr.next() == Some(3)\n</code></pre> <p>zip larger with smaller:</p> <pre><code>&gt;&gt;&gt; inf_itr = seq(...)\n&gt;&gt;&gt; foo_itr = iterum(\"foo\")\n&gt;&gt;&gt; zip_itr = inf_itr.zip(foo_itr)\n&gt;&gt;&gt; assert zip_itr.next() == Some((0, \"f\"))\n&gt;&gt;&gt; assert zip_itr.next() == Some((1, \"o\"))\n&gt;&gt;&gt; assert zip_itr.next() == Some((2, \"o\"))\n&gt;&gt;&gt; assert zip_itr.next() == nil\n&gt;&gt;&gt; assert foo_itr.next() == nil\n&gt;&gt;&gt; assert inf_itr.next() == Some(4)\n</code></pre> Source code in <code>iterum/_iterum.py</code> <pre><code>def zip(self, other: Iterable[U], /) -&gt; Zip[T_co, U]:\n\"\"\"\n    \u2018Zips up\u2019 two iterables into a single iterum of pairs.\n    [zip()][iterum.Iterum.zip] returns a new iterum that will iterate over\n    two other iterables, returning a tuple where the first element comes\n    from the first iterable, and the second element comes from the second iterable.\n    If either iterable returns [nil][iterum.nil], next from the zipped\n    iterum will return [nil][iterum.nil]. If the zipped iterum has no\n    more elements to return then each further attempt to advance it will\n    first try to advance the first iterable at most one time and if it still\n    yielded an item try to advance the second iterable at most one time.\n    To \u2018undo\u2019 the result of zipping up two iterables, see [unzip][iterum.Iterum.unzip].\n    Examples:\n        &gt;&gt;&gt; a1 = [1, 2, 3]\n        &gt;&gt;&gt; a2 = [4, 5, 6]\n        &gt;&gt;&gt; itr = iterum(a1).zip(a2)\n        &gt;&gt;&gt; assert itr.next() == Some((1, 4))\n        &gt;&gt;&gt; assert itr.next() == Some((2, 5))\n        &gt;&gt;&gt; assert itr.next() == Some((3, 6))\n        &gt;&gt;&gt; assert itr.next() == nil\n        zip smaller with larger:\n        &gt;&gt;&gt; inf_itr = seq(...)\n        &gt;&gt;&gt; foo_itr = iterum(\"foo\")\n        &gt;&gt;&gt; zip_itr = foo_itr.zip(inf_itr)\n        &gt;&gt;&gt; assert zip_itr.next() == Some((\"f\", 0))\n        &gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 1))\n        &gt;&gt;&gt; assert zip_itr.next() == Some((\"o\", 2))\n        &gt;&gt;&gt; assert zip_itr.next() == nil\n        &gt;&gt;&gt; assert foo_itr.next() == nil\n        &gt;&gt;&gt; assert inf_itr.next() == Some(3)\n        zip larger with smaller:\n        &gt;&gt;&gt; inf_itr = seq(...)\n        &gt;&gt;&gt; foo_itr = iterum(\"foo\")\n        &gt;&gt;&gt; zip_itr = inf_itr.zip(foo_itr)\n        &gt;&gt;&gt; assert zip_itr.next() == Some((0, \"f\"))\n        &gt;&gt;&gt; assert zip_itr.next() == Some((1, \"o\"))\n        &gt;&gt;&gt; assert zip_itr.next() == Some((2, \"o\"))\n        &gt;&gt;&gt; assert zip_itr.next() == nil\n        &gt;&gt;&gt; assert foo_itr.next() == nil\n        &gt;&gt;&gt; assert inf_itr.next() == Some(4)\n    \"\"\"\nreturn Zip(self, other)\n</code></pre>"},{"location":"api/#iterum.diterum","title":"<code>iterum.diterum</code>","text":"<p>         Bases: <code>Diterum[T_co]</code></p> <p>Implements a Diterum interface from a sequence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = diterum([1, 2, 3])\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next_back() == Some(3)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next_back() == nil\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <pre><code>&gt;&gt;&gt; itr = diterum([1, 2, 3])\n&gt;&gt;&gt; assert itr.rfold(0, lambda acc, x: acc*2 + x) == 17\n</code></pre> <pre><code>&gt;&gt;&gt; x = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; y = (\n...     diterum(x)\n...     .rev()\n...     .map(lambda x: x**2 + 1)\n...     .filter(lambda x: x % 2)\n...     .collect()\n... )\n&gt;&gt;&gt; assert y == [17, 5, 1]\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>class diterum(Diterum[T_co]):\n\"\"\"\n    Implements a [Diterum][iterum.Diterum] interface from a sequence.\n    Examples:\n        &gt;&gt;&gt; itr = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next_back() == Some(3)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next_back() == nil\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; itr = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert itr.rfold(0, lambda acc, x: acc*2 + x) == 17\n        &gt;&gt;&gt; x = [0, 1, 2, 3, 4]\n        &gt;&gt;&gt; y = (\n        ...     diterum(x)\n        ...     .rev()\n        ...     .map(lambda x: x**2 + 1)\n        ...     .filter(lambda x: x % 2)\n        ...     .collect()\n        ... )\n        &gt;&gt;&gt; assert y == [17, 5, 1]\n    \"\"\"\n__slots__ = (\"_seq\", \"_front\", \"_back\")\ndef __init__(self, __seq: Sequence[T_co], /) -&gt; None:\nself._seq = __seq\nself._front = 0\nself._back = len(__seq) - 1\ndef next(self) -&gt; Option[T_co]:\n\"\"\"\n        Returns the next value in the sequence from the front if present,\n        otherwise [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; itr = diterum([1, 2])\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.next() == Some(2)\n            &gt;&gt;&gt; assert itr.next() == nil\n        \"\"\"\nif self._back &lt; self._front:\nreturn nil\nnxt = self._seq[self._front]\nself._front += 1\nreturn Some(nxt)\ndef next_back(self) -&gt; Option[T_co]:\n\"\"\"\n        Returns the next value in the sequence from the back if present,\n        otherwise [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; itr = diterum([1, 2])\n            &gt;&gt;&gt; assert itr.next_back() == Some(2)\n            &gt;&gt;&gt; assert itr.next_back() == Some(1)\n            &gt;&gt;&gt; assert itr.next_back() == nil\n        \"\"\"\nif self._back &lt; self._front:\nreturn nil\nnxt = self._seq[self._back]\nself._back -= 1\nreturn Some(nxt)\ndef len(self) -&gt; int:\n\"\"\"\n        Returns the remaining length of the sequence.\n        Examples:\n            &gt;&gt;&gt; itr = diterum([1, 2])\n            &gt;&gt;&gt; assert itr.len() == 2\n            &gt;&gt;&gt; assert itr.next() == Some(1)\n            &gt;&gt;&gt; assert itr.len() == 1\n            &gt;&gt;&gt; assert itr.next_back() == Some(2)\n            &gt;&gt;&gt; assert itr.len() == 0\n            &gt;&gt;&gt; assert itr.next() == nil\n            &gt;&gt;&gt; assert itr.len() == 0\n        \"\"\"\nif self._back &lt; self._front:\nreturn 0\nreturn self._back + 1 - self._front\n</code></pre>"},{"location":"api/#iterum._diterum.diterum.next","title":"<code>next() -&gt; Option[T_co]</code>","text":"<p>Returns the next value in the sequence from the front if present, otherwise nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = diterum([1, 2])\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def next(self) -&gt; Option[T_co]:\n\"\"\"\n    Returns the next value in the sequence from the front if present,\n    otherwise [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; itr = diterum([1, 2])\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n    \"\"\"\nif self._back &lt; self._front:\nreturn nil\nnxt = self._seq[self._front]\nself._front += 1\nreturn Some(nxt)\n</code></pre>"},{"location":"api/#iterum._diterum.diterum.next_back","title":"<code>next_back() -&gt; Option[T_co]</code>","text":"<p>Returns the next value in the sequence from the back if present, otherwise nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = diterum([1, 2])\n&gt;&gt;&gt; assert itr.next_back() == Some(2)\n&gt;&gt;&gt; assert itr.next_back() == Some(1)\n&gt;&gt;&gt; assert itr.next_back() == nil\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def next_back(self) -&gt; Option[T_co]:\n\"\"\"\n    Returns the next value in the sequence from the back if present,\n    otherwise [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; itr = diterum([1, 2])\n        &gt;&gt;&gt; assert itr.next_back() == Some(2)\n        &gt;&gt;&gt; assert itr.next_back() == Some(1)\n        &gt;&gt;&gt; assert itr.next_back() == nil\n    \"\"\"\nif self._back &lt; self._front:\nreturn nil\nnxt = self._seq[self._back]\nself._back -= 1\nreturn Some(nxt)\n</code></pre>"},{"location":"api/#iterum._diterum.diterum.len","title":"<code>len() -&gt; int</code>","text":"<p>Returns the remaining length of the sequence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = diterum([1, 2])\n&gt;&gt;&gt; assert itr.len() == 2\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.len() == 1\n&gt;&gt;&gt; assert itr.next_back() == Some(2)\n&gt;&gt;&gt; assert itr.len() == 0\n&gt;&gt;&gt; assert itr.next() == nil\n&gt;&gt;&gt; assert itr.len() == 0\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def len(self) -&gt; int:\n\"\"\"\n    Returns the remaining length of the sequence.\n    Examples:\n        &gt;&gt;&gt; itr = diterum([1, 2])\n        &gt;&gt;&gt; assert itr.len() == 2\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.len() == 1\n        &gt;&gt;&gt; assert itr.next_back() == Some(2)\n        &gt;&gt;&gt; assert itr.len() == 0\n        &gt;&gt;&gt; assert itr.next() == nil\n        &gt;&gt;&gt; assert itr.len() == 0\n    \"\"\"\nif self._back &lt; self._front:\nreturn 0\nreturn self._back + 1 - self._front\n</code></pre>"},{"location":"api/#iterum.Diterum","title":"<code>iterum.Diterum</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> <p>Iterator-like abstract base class that is reversible and of known size. To implement this, inherit from Diterum and then define a next, next_back, and len method. See diterum for an example.</p> Source code in <code>iterum/_diterum.py</code> <pre><code>class Diterum(Iterum[T_co]):\n\"\"\"\n    Iterator-like abstract base class that is reversible and of known size.\n    To implement this, inherit from [Diterum][iterum.Diterum] and then define\n    a [next][iterum.Iterum.next], [next_back][iterum.Diterum.next_back], and\n    [len][iterum.Diterum.len] method. See [diterum][iterum.diterum] for an\n    example.\n    \"\"\"\n__slots__ = ()\n@abstractmethod\ndef next_back(self) -&gt; Option[T_co]:\n\"\"\"\n        Required method.\n        Removes and returns an element from the end of the diterum.\n        Returns [nil][iterum.nil] when there are no more elements.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3, 4, 5, 6])\n            &gt;&gt;&gt; assert di.next() == Some(1)\n            &gt;&gt;&gt; assert di.next_back() == Some(6)\n            &gt;&gt;&gt; assert di.next_back() == Some(5)\n            &gt;&gt;&gt; assert di.next() == Some(2)\n            &gt;&gt;&gt; assert di.next() == Some(3)\n            &gt;&gt;&gt; assert di.next() == Some(4)\n            &gt;&gt;&gt; assert di.next() == nil\n            &gt;&gt;&gt; assert di.next_back() == nil\n        \"\"\"\n...\n@abstractmethod\ndef len(self) -&gt; int:\n\"\"\"\n        Required method.\n        Returns the exact remaining length of the diterum.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3, 4])\n            &gt;&gt;&gt; assert di.len() == 4\n            &gt;&gt;&gt; assert di.next() == Some(1)\n            &gt;&gt;&gt; assert di.len() == 3\n            &gt;&gt;&gt; assert di.next_back() == Some(4)\n            &gt;&gt;&gt; assert di.len() == 2\n            &gt;&gt;&gt; assert di.collect() == [2, 3]\n            &gt;&gt;&gt; assert di.next() == nil\n            &gt;&gt;&gt; assert di.len() == 0\n        \"\"\"\n...\n# Defined by Iterator\ndef rev(self) -&gt; Rev[T_co]:\n\"\"\"\n        Reverses an diterum\u2019s direction.\n        Usually, iterums iterate from left to right. After using\n        [rev()][iterum.Diterum.rev], an iterum will instead iterate from\n        right to left.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3]).rev()\n            &gt;&gt;&gt; assert di.next() == Some(3)\n            &gt;&gt;&gt; assert di.next() == Some(2)\n            &gt;&gt;&gt; assert di.next() == Some(1)\n            &gt;&gt;&gt; assert di.next() == nil\n        \"\"\"\nreturn Rev(self)\ndef rposition(self, predicate: Callable[[T_co], object], /) -&gt; Option[int]:\n\"\"\"\n        Searches for an element in a diterum from the right, returning its index.\n        [rposition()][iterum.Diterum.rposition] takes a closure that returns\n        `True` or `False`. It applies this closure to each element of the\n        diterum, starting from the end, and if one of them returns `True`, then\n        [rposition()][iterum.Diterum.rposition] returns [Some(index)][iterum.Some].\n        If all of them return `False`, it returns [nil][iterum.nil].\n        [rposition()][iterum.Diterum.rposition] is short-circuiting; in other\n        words, it will stop processing as soon as it finds a `True`.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.rposition(lambda x: x == 3) == Some(2)\n            &gt;&gt;&gt; assert di.rposition(lambda x: x == 5) == nil\n            Short-circuiting after first `True`:\n            &gt;&gt;&gt; di = diterum([-1, 2, 3, 4])\n            &gt;&gt;&gt; assert di.rposition(lambda x: x &gt;= 2) == Some(3)\n            &gt;&gt;&gt; assert di.next() == Some(-1)\n        \"\"\"\nlen = self.len()\nreturn self.rev().position(predicate).map(lambda x: len - x - 1)\n# Defined by DoubleEndedIterator\ndef nth_back(self, n: int, /) -&gt; Option[T_co]:\n\"\"\"\n        Returns the nth element from the end of the diterum.\n        This is essentially the reversed version of [Iterum.nth()][iterum.Iterum.nth].\n        Although like most indexing operations, the count starts from zero, so\n        [nth_back(0)][iterum.Diterum.nth_back] returns the first value from the end,\n        [nth_back(1)][iterum.Diterum.nth_back] the second, and so on.\n        Note that all elements between the end and the returned element will be\n        consumed, including the returned element. This also means that calling\n        [nth_back(0)][iterum.Diterum.nth_back] multiple times on the same diterum\n        will return different elements.\n        [nth_back()][iterum.Diterum.nth_back] will return [nil][iterum.nil] if n\n        is greater than or equal to the length of the diterum.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.nth_back(2) == Some(1)\n            Does not rewind:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.nth_back(1) == Some(2)\n            &gt;&gt;&gt; assert di.nth_back(1) == nil\n            Returns [nil][iterum.nil] if there are less than `n + 1` elements:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.nth_back(10) == nil\n        \"\"\"\nreturn self.rev().nth(n)\ndef rfind(self, predicate: Callable[[T_co], object], /) -&gt; Option[T_co]:\n\"\"\"\n        Searches for an element of a diterum from the back that satisfies a predicate.\n        [rfind()][iterum.Diterum.rfind] takes a closure that returns `True` or\n        `False`. It applies this closure to each element of the diterum,\n        starting at the end, and if any of them return `True`, then\n        [rfind()][iterum.Diterum.rfind] returns [Some(element)][iterum.Some]. If\n        they all return `False`, it returns [nil][iterum.nil].\n        [rfind()][iterum.Diterum.rfind] is short-circuiting; in other words, it\n        will stop processing as soon as the closure returns `True`.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n            &gt;&gt;&gt; assert di.rfind(lambda x: x == 5) == nil\n            Stops at first `True`:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n            &gt;&gt;&gt; assert di.next_back() == Some(1)\n        \"\"\"\nreturn self.rev().find(predicate)\ndef rfold(self, init: U, f: Callable[[U, T_co], U], /) -&gt; U:\n\"\"\"\n        A diterum method that reduces the diterum\u2019s elements to a single,\n        final value, starting from the back.\n        This is the reverse version of [Iterum.fold()][iterum.Iterum.fold]:\n        it takes elements starting from the back of the diterum.\n        [rfold()][iterum.Diterum.rfold] takes two arguments: an initial value,\n        and a closure with two arguments: an \u2018accumulator\u2019, and an element. The\n        closure returns the value that the accumulator should have for the next\n        iteration.\n        The initial value is the value the accumulator will have on the first call.\n        After applying this closure to every element of the diterum,\n        [rfold()][iterum.Diterum.rfold] returns the accumulator.\n        Examples:\n            &gt;&gt;&gt; di = diterum([1, 2, 3])\n            &gt;&gt;&gt; sum = di.rfold(0, lambda acc, x: acc + x)\n            &gt;&gt;&gt; assert sum == 6\n        rfold is right-associtive:\n            ```python\n            &gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n            &gt;&gt;&gt; zero = \"0\"\n            &gt;&gt;&gt; result = diterum(numbers).rfold(zero, lambda acc, x: f\"({x} + {acc})\")\n            &gt;&gt;&gt; assert result == \"(1 + (2 + (3 + (4 + (5 + 0)))))\"\n            ```\n        \"\"\"\nreturn self.rev().fold(init, f)\ndef try_rfold(\nself,\ninit: U,\nf: Callable[[U, T_co], U],\n/,\n*,\nexception: type[BaseException] | tuple[type[BaseException], ...] = Exception,\n) -&gt; Option[U]:\n\"\"\"\n        This is the reverse version of [Iterum.try_fold()][iterum.Iterum.try_fold]:\n        it takes elements starting from the back of the diterum.\n        Examples:\n            &gt;&gt;&gt; di = diterum([\"1\", \"2\", \"3\"])\n            &gt;&gt;&gt; sum = di.try_rfold(0, lambda acc, x: acc + int(x), exception=TypeError)\n            &gt;&gt;&gt; assert sum == Some(6)\n        \"\"\"\nreturn self.rev().try_fold(init, f, exception=exception)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.next_back","title":"<code>next_back() -&gt; Option[T_co]</code>  <code>abstractmethod</code>","text":"<p>Required method.</p> <p>Removes and returns an element from the end of the diterum.</p> <p>Returns nil when there are no more elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3, 4, 5, 6])\n&gt;&gt;&gt; assert di.next() == Some(1)\n&gt;&gt;&gt; assert di.next_back() == Some(6)\n&gt;&gt;&gt; assert di.next_back() == Some(5)\n&gt;&gt;&gt; assert di.next() == Some(2)\n&gt;&gt;&gt; assert di.next() == Some(3)\n&gt;&gt;&gt; assert di.next() == Some(4)\n&gt;&gt;&gt; assert di.next() == nil\n&gt;&gt;&gt; assert di.next_back() == nil\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>@abstractmethod\ndef next_back(self) -&gt; Option[T_co]:\n\"\"\"\n    Required method.\n    Removes and returns an element from the end of the diterum.\n    Returns [nil][iterum.nil] when there are no more elements.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3, 4, 5, 6])\n        &gt;&gt;&gt; assert di.next() == Some(1)\n        &gt;&gt;&gt; assert di.next_back() == Some(6)\n        &gt;&gt;&gt; assert di.next_back() == Some(5)\n        &gt;&gt;&gt; assert di.next() == Some(2)\n        &gt;&gt;&gt; assert di.next() == Some(3)\n        &gt;&gt;&gt; assert di.next() == Some(4)\n        &gt;&gt;&gt; assert di.next() == nil\n        &gt;&gt;&gt; assert di.next_back() == nil\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.len","title":"<code>len() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Required method.</p> <p>Returns the exact remaining length of the diterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3, 4])\n&gt;&gt;&gt; assert di.len() == 4\n&gt;&gt;&gt; assert di.next() == Some(1)\n&gt;&gt;&gt; assert di.len() == 3\n&gt;&gt;&gt; assert di.next_back() == Some(4)\n&gt;&gt;&gt; assert di.len() == 2\n&gt;&gt;&gt; assert di.collect() == [2, 3]\n&gt;&gt;&gt; assert di.next() == nil\n&gt;&gt;&gt; assert di.len() == 0\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>@abstractmethod\ndef len(self) -&gt; int:\n\"\"\"\n    Required method.\n    Returns the exact remaining length of the diterum.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3, 4])\n        &gt;&gt;&gt; assert di.len() == 4\n        &gt;&gt;&gt; assert di.next() == Some(1)\n        &gt;&gt;&gt; assert di.len() == 3\n        &gt;&gt;&gt; assert di.next_back() == Some(4)\n        &gt;&gt;&gt; assert di.len() == 2\n        &gt;&gt;&gt; assert di.collect() == [2, 3]\n        &gt;&gt;&gt; assert di.next() == nil\n        &gt;&gt;&gt; assert di.len() == 0\n    \"\"\"\n...\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.rev","title":"<code>rev() -&gt; Rev[T_co]</code>","text":"<p>Reverses an diterum\u2019s direction.</p> <p>Usually, iterums iterate from left to right. After using rev(), an iterum will instead iterate from right to left.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3]).rev()\n&gt;&gt;&gt; assert di.next() == Some(3)\n&gt;&gt;&gt; assert di.next() == Some(2)\n&gt;&gt;&gt; assert di.next() == Some(1)\n&gt;&gt;&gt; assert di.next() == nil\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def rev(self) -&gt; Rev[T_co]:\n\"\"\"\n    Reverses an diterum\u2019s direction.\n    Usually, iterums iterate from left to right. After using\n    [rev()][iterum.Diterum.rev], an iterum will instead iterate from\n    right to left.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3]).rev()\n        &gt;&gt;&gt; assert di.next() == Some(3)\n        &gt;&gt;&gt; assert di.next() == Some(2)\n        &gt;&gt;&gt; assert di.next() == Some(1)\n        &gt;&gt;&gt; assert di.next() == nil\n    \"\"\"\nreturn Rev(self)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.rposition","title":"<code>rposition(predicate: Callable[[T_co], object]) -&gt; Option[int]</code>","text":"<p>Searches for an element in a diterum from the right, returning its index.</p> <p>rposition() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the diterum, starting from the end, and if one of them returns <code>True</code>, then rposition() returns Some(index). If all of them return <code>False</code>, it returns nil.</p> <p>rposition() is short-circuiting; in other words, it will stop processing as soon as it finds a <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.rposition(lambda x: x == 3) == Some(2)\n&gt;&gt;&gt; assert di.rposition(lambda x: x == 5) == nil\n</code></pre> <p>Short-circuiting after first <code>True</code>:</p> <pre><code>&gt;&gt;&gt; di = diterum([-1, 2, 3, 4])\n&gt;&gt;&gt; assert di.rposition(lambda x: x &gt;= 2) == Some(3)\n&gt;&gt;&gt; assert di.next() == Some(-1)\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def rposition(self, predicate: Callable[[T_co], object], /) -&gt; Option[int]:\n\"\"\"\n    Searches for an element in a diterum from the right, returning its index.\n    [rposition()][iterum.Diterum.rposition] takes a closure that returns\n    `True` or `False`. It applies this closure to each element of the\n    diterum, starting from the end, and if one of them returns `True`, then\n    [rposition()][iterum.Diterum.rposition] returns [Some(index)][iterum.Some].\n    If all of them return `False`, it returns [nil][iterum.nil].\n    [rposition()][iterum.Diterum.rposition] is short-circuiting; in other\n    words, it will stop processing as soon as it finds a `True`.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.rposition(lambda x: x == 3) == Some(2)\n        &gt;&gt;&gt; assert di.rposition(lambda x: x == 5) == nil\n        Short-circuiting after first `True`:\n        &gt;&gt;&gt; di = diterum([-1, 2, 3, 4])\n        &gt;&gt;&gt; assert di.rposition(lambda x: x &gt;= 2) == Some(3)\n        &gt;&gt;&gt; assert di.next() == Some(-1)\n    \"\"\"\nlen = self.len()\nreturn self.rev().position(predicate).map(lambda x: len - x - 1)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.nth_back","title":"<code>nth_back(n: int) -&gt; Option[T_co]</code>","text":"<p>Returns the nth element from the end of the diterum.</p> <p>This is essentially the reversed version of Iterum.nth(). Although like most indexing operations, the count starts from zero, so nth_back(0) returns the first value from the end, nth_back(1) the second, and so on.</p> <p>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling nth_back(0) multiple times on the same diterum will return different elements.</p> <p>nth_back() will return nil if n is greater than or equal to the length of the diterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.nth_back(2) == Some(1)\n</code></pre> <p>Does not rewind:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.nth_back(1) == Some(2)\n&gt;&gt;&gt; assert di.nth_back(1) == nil\n</code></pre> <p>Returns nil if there are less than <code>n + 1</code> elements:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.nth_back(10) == nil\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def nth_back(self, n: int, /) -&gt; Option[T_co]:\n\"\"\"\n    Returns the nth element from the end of the diterum.\n    This is essentially the reversed version of [Iterum.nth()][iterum.Iterum.nth].\n    Although like most indexing operations, the count starts from zero, so\n    [nth_back(0)][iterum.Diterum.nth_back] returns the first value from the end,\n    [nth_back(1)][iterum.Diterum.nth_back] the second, and so on.\n    Note that all elements between the end and the returned element will be\n    consumed, including the returned element. This also means that calling\n    [nth_back(0)][iterum.Diterum.nth_back] multiple times on the same diterum\n    will return different elements.\n    [nth_back()][iterum.Diterum.nth_back] will return [nil][iterum.nil] if n\n    is greater than or equal to the length of the diterum.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.nth_back(2) == Some(1)\n        Does not rewind:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.nth_back(1) == Some(2)\n        &gt;&gt;&gt; assert di.nth_back(1) == nil\n        Returns [nil][iterum.nil] if there are less than `n + 1` elements:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.nth_back(10) == nil\n    \"\"\"\nreturn self.rev().nth(n)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.rfind","title":"<code>rfind(predicate: Callable[[T_co], object]) -&gt; Option[T_co]</code>","text":"<p>Searches for an element of a diterum from the back that satisfies a predicate.</p> <p>rfind() takes a closure that returns <code>True</code> or <code>False</code>. It applies this closure to each element of the diterum, starting at the end, and if any of them return <code>True</code>, then rfind() returns Some(element). If they all return <code>False</code>, it returns nil.</p> <p>rfind() is short-circuiting; in other words, it will stop processing as soon as the closure returns <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n&gt;&gt;&gt; assert di.rfind(lambda x: x == 5) == nil\n</code></pre> <p>Stops at first <code>True</code>:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n&gt;&gt;&gt; assert di.next_back() == Some(1)\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def rfind(self, predicate: Callable[[T_co], object], /) -&gt; Option[T_co]:\n\"\"\"\n    Searches for an element of a diterum from the back that satisfies a predicate.\n    [rfind()][iterum.Diterum.rfind] takes a closure that returns `True` or\n    `False`. It applies this closure to each element of the diterum,\n    starting at the end, and if any of them return `True`, then\n    [rfind()][iterum.Diterum.rfind] returns [Some(element)][iterum.Some]. If\n    they all return `False`, it returns [nil][iterum.nil].\n    [rfind()][iterum.Diterum.rfind] is short-circuiting; in other words, it\n    will stop processing as soon as the closure returns `True`.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n        &gt;&gt;&gt; assert di.rfind(lambda x: x == 5) == nil\n        Stops at first `True`:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; assert di.rfind(lambda x: x == 2) == Some(2)\n        &gt;&gt;&gt; assert di.next_back() == Some(1)\n    \"\"\"\nreturn self.rev().find(predicate)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.rfold","title":"<code>rfold(init: U, f: Callable[[U, T_co], U]) -&gt; U</code>","text":"<p>A diterum method that reduces the diterum\u2019s elements to a single, final value, starting from the back.</p> <p>This is the reverse version of Iterum.fold(): it takes elements starting from the back of the diterum.</p> <p>rfold() takes two arguments: an initial value, and a closure with two arguments: an \u2018accumulator\u2019, and an element. The closure returns the value that the accumulator should have for the next iteration.</p> <p>The initial value is the value the accumulator will have on the first call.</p> <p>After applying this closure to every element of the diterum, rfold() returns the accumulator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([1, 2, 3])\n&gt;&gt;&gt; sum = di.rfold(0, lambda acc, x: acc + x)\n&gt;&gt;&gt; assert sum == 6\n</code></pre> rfold is right-associtive <pre><code>&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; zero = \"0\"\n&gt;&gt;&gt; result = diterum(numbers).rfold(zero, lambda acc, x: f\"({x} + {acc})\")\n&gt;&gt;&gt; assert result == \"(1 + (2 + (3 + (4 + (5 + 0)))))\"\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def rfold(self, init: U, f: Callable[[U, T_co], U], /) -&gt; U:\n\"\"\"\n    A diterum method that reduces the diterum\u2019s elements to a single,\n    final value, starting from the back.\n    This is the reverse version of [Iterum.fold()][iterum.Iterum.fold]:\n    it takes elements starting from the back of the diterum.\n    [rfold()][iterum.Diterum.rfold] takes two arguments: an initial value,\n    and a closure with two arguments: an \u2018accumulator\u2019, and an element. The\n    closure returns the value that the accumulator should have for the next\n    iteration.\n    The initial value is the value the accumulator will have on the first call.\n    After applying this closure to every element of the diterum,\n    [rfold()][iterum.Diterum.rfold] returns the accumulator.\n    Examples:\n        &gt;&gt;&gt; di = diterum([1, 2, 3])\n        &gt;&gt;&gt; sum = di.rfold(0, lambda acc, x: acc + x)\n        &gt;&gt;&gt; assert sum == 6\n    rfold is right-associtive:\n        ```python\n        &gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; zero = \"0\"\n        &gt;&gt;&gt; result = diterum(numbers).rfold(zero, lambda acc, x: f\"({x} + {acc})\")\n        &gt;&gt;&gt; assert result == \"(1 + (2 + (3 + (4 + (5 + 0)))))\"\n        ```\n    \"\"\"\nreturn self.rev().fold(init, f)\n</code></pre>"},{"location":"api/#iterum._diterum.Diterum.try_rfold","title":"<code>try_rfold(init: U, f: Callable[[U, T_co], U], /, *, exception: type[BaseException] | tuple[type[BaseException], ...] = Exception) -&gt; Option[U]</code>","text":"<p>This is the reverse version of Iterum.try_fold(): it takes elements starting from the back of the diterum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; di = diterum([\"1\", \"2\", \"3\"])\n&gt;&gt;&gt; sum = di.try_rfold(0, lambda acc, x: acc + int(x), exception=TypeError)\n&gt;&gt;&gt; assert sum == Some(6)\n</code></pre> Source code in <code>iterum/_diterum.py</code> <pre><code>def try_rfold(\nself,\ninit: U,\nf: Callable[[U, T_co], U],\n/,\n*,\nexception: type[BaseException] | tuple[type[BaseException], ...] = Exception,\n) -&gt; Option[U]:\n\"\"\"\n    This is the reverse version of [Iterum.try_fold()][iterum.Iterum.try_fold]:\n    it takes elements starting from the back of the diterum.\n    Examples:\n        &gt;&gt;&gt; di = diterum([\"1\", \"2\", \"3\"])\n        &gt;&gt;&gt; sum = di.try_rfold(0, lambda acc, x: acc + int(x), exception=TypeError)\n        &gt;&gt;&gt; assert sum == Some(6)\n    \"\"\"\nreturn self.rev().try_fold(init, f, exception=exception)\n</code></pre>"},{"location":"api/#iterum.seq","title":"<code>iterum.seq(start: SupportsIndex | EllipsisType, end: SupportsIndex | EllipsisType | NotSetType = NotSet, /, step: SupportsIndex = 1) -&gt; Seq | InfSeq</code>","text":"<p>Count sequentially from start to end in step sizes.</p> <p>If a finite end is provided, an instance of Seq is returned.</p> <p>If an infinite end is provided (using ellipsis <code>...</code>), an instance of InfSeq is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itr = seq(3)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Can also specify a start and step:</p> <pre><code>&gt;&gt;&gt; itr = seq(3, 9, 3)\n&gt;&gt;&gt; assert itr.next() == Some(3)\n&gt;&gt;&gt; assert itr.next() == Some(6)\n&gt;&gt;&gt; assert itr.next() == nil\n</code></pre> <p>Finite ranges implement Diterum:</p> <pre><code>&gt;&gt;&gt; itr = seq(3)\n&gt;&gt;&gt; assert itr.len() == 3\n&gt;&gt;&gt; assert itr.next_back() == Some(2)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n</code></pre> <p>Specify an infinite range using <code>...</code>:</p> <pre><code>&gt;&gt;&gt; itr = seq(...)\n&gt;&gt;&gt; assert itr.next() == Some(0)\n&gt;&gt;&gt; assert itr.next() == Some(1)\n&gt;&gt;&gt; assert itr.next() == Some(2)\n&gt;&gt;&gt; # will continue forever!\n</code></pre> <p>Similarly a start and step can be specified:</p> <pre><code>&gt;&gt;&gt; itr = seq(-10, ..., -1)\n&gt;&gt;&gt; assert itr.next() == Some(-10)\n&gt;&gt;&gt; assert itr.next() == Some(-11)\n&gt;&gt;&gt; assert itr.next() == Some(-12)\n&gt;&gt;&gt; # will continue forever!\n</code></pre> Source code in <code>iterum/_seq.py</code> <pre><code>def seq(\nstart: SupportsIndex | EllipsisType,\nend: SupportsIndex | EllipsisType | NotSetType = NotSet,\n/,\nstep: SupportsIndex = 1,\n) -&gt; Seq | InfSeq:\n\"\"\"\n    Count sequentially from start to end in step sizes.\n    If a finite end is provided, an instance of [Seq][iterum.Seq] is returned.\n    If an infinite end is provided (using ellipsis `...`), an instance of\n    [InfSeq][iterum.InfSeq] is returned.\n    Examples:\n        &gt;&gt;&gt; itr = seq(3)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == nil\n        Can also specify a start and step:\n        &gt;&gt;&gt; itr = seq(3, 9, 3)\n        &gt;&gt;&gt; assert itr.next() == Some(3)\n        &gt;&gt;&gt; assert itr.next() == Some(6)\n        &gt;&gt;&gt; assert itr.next() == nil\n        Finite ranges implement [Diterum][iterum.Diterum]:\n        &gt;&gt;&gt; itr = seq(3)\n        &gt;&gt;&gt; assert itr.len() == 3\n        &gt;&gt;&gt; assert itr.next_back() == Some(2)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        Specify an infinite range using `...`:\n        &gt;&gt;&gt; itr = seq(...)\n        &gt;&gt;&gt; assert itr.next() == Some(0)\n        &gt;&gt;&gt; assert itr.next() == Some(1)\n        &gt;&gt;&gt; assert itr.next() == Some(2)\n        &gt;&gt;&gt; # will continue forever!\n        Similarly a start and step can be specified:\n        &gt;&gt;&gt; itr = seq(-10, ..., -1)\n        &gt;&gt;&gt; assert itr.next() == Some(-10)\n        &gt;&gt;&gt; assert itr.next() == Some(-11)\n        &gt;&gt;&gt; assert itr.next() == Some(-12)\n        &gt;&gt;&gt; # will continue forever!\n    \"\"\"\nif isinstance(end, NotSetType):\nstart, end = 0, start\nelif start is ...:\nraise TypeError(\"Start cannot be set to '...'\")\nstart = operator.index(start)\nend = ... if end is ... else operator.index(end)\nstep = operator.index(step)\nif end is ...:\nreturn InfSeq(start=start, step=step)\nelse:\nreturn Seq(start=start, end=end, step=step)\n</code></pre>"},{"location":"api/#iterum.Option","title":"<code>iterum.Option: TypeAlias = 'Some[T] | Nil'</code>  <code>module-attribute</code>","text":"<p>Type alias representing something which is either of type Some or Nil.</p> <p>Examples:</p> <p>Type annotate a function which returns <code>Some[int]</code> or <code>nil</code>:</p> <pre><code>&gt;&gt;&gt; def checked_div(num: int, dem: int) -&gt; Option[int]:\n...     try:\n...         return Some(num // dem)\n...     except ZeroDivisionError:\n...         return nil\n...\n</code></pre> <p>Use <code>isinstance</code> to narrow the type:</p> <pre><code>&gt;&gt;&gt; x = checked_div(10, 3)\n&gt;&gt;&gt; reveal_type(x)  # Type of \"x\" is \"Some[int] | Nil\"\n&gt;&gt;&gt; if isinstance(x, Some):\n...     reveal_type(x)  # Type of \"x\" is \"Some[int]\"\n... else:\n...     reveal_type(x)  # Type of \"x\" is \"Nil\"\n...\n</code></pre> <p>Alternatively use pattern matching:</p> <pre><code>&gt;&gt;&gt; match x:\n...     case Some(value):\n...         print(f\"Result: {value=}\")\n...     case Nil:\n...         print(\"Cannot divide by 0\")\n...\n</code></pre> <p>}</p>"},{"location":"api/#iterum.Some","title":"<code>iterum.Some</code>","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Some value of type T.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(1)  # Type of \"x\" is \"Some[int]\"\n&gt;&gt;&gt; x\nSome(1)\n&gt;&gt;&gt; x.is_some()\nTrue\n&gt;&gt;&gt; x.unwrap()\n1\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>class Some(Generic[T]):\n\"\"\"\n    [Some][iterum.Some] value of type T.\n    Examples:\n        &gt;&gt;&gt; x = Some(1)  # Type of \"x\" is \"Some[int]\"\n        &gt;&gt;&gt; x\n        Some(1)\n        &gt;&gt;&gt; x.is_some()\n        True\n        &gt;&gt;&gt; x.unwrap()\n        1\n    \"\"\"\n__match_args__ = (\"_value\",)\ndef __init__(self, value: T, /) -&gt; None:\nself._value = value\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, Some):\nreturn NotImplemented\nreturn self._value == other._value\ndef __repr__(self) -&gt; str:\nreturn f\"{Some.__name__}({self._value!r})\"\ndef __bool__(self) -&gt; Literal[True]:\nreturn True\ndef and_(self, optb: O, /) -&gt; O:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        returns optb.\n        Arguments passed to [and_][iterum.Some.and_] are eagerly evaluated; if\n        you are passing the result of a function call, it is recommended to use\n        [and_then][iterum.Some.and_then], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).and_(nil) == nil\n            &gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n            &gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n            &gt;&gt;&gt; assert nil.and_(nil) == nil\n        Note: because `and` is a keyword, this method is called `and_` instead.\n        \"\"\"\nreturn optb\ndef and_then(self, f: Callable[[T], O], /) -&gt; O:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        calls `f` with the wrapped value and returns the result.\n        Examples:\n            &gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n            &gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n            ...     sq = x * x\n            ...     if sq &gt; MAX_U32:\n            ...         return nil\n            ...     return Some(sq)\n            ...\n            &gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n            &gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n            &gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n        \"\"\"\nreturn f(self._value)\ndef expect(self, msg: str, /) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value, consuming the self value.\n        Examples:\n            &gt;&gt;&gt; x = Some(\"value\")\n            &gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n            &gt;&gt;&gt; try:\n            ...     nil.expect(\"fruits are healthy\")\n            ... except ExpectNilError as ex:\n            ...     print(ex)\n            ...\n            fruits are healthy\n        Raises:\n            ExpectNilError: if the value is a [nil][iterum.nil] with a custom\n                message provided by msg.\n        \"\"\"\nreturn self._value\ndef filter(self, predicate: Callable[[T], object], /) -&gt; Option[T]:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        calls `predicate` with the wrapped value and returns:\n            - [Some(value)][iterum.Some] if the predicate returns `True`\n            - [nil][iterum.nil] if the predicate returns `False`\n        Examples:\n            &gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n            &gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n            &gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n        \"\"\"\nreturn self if predicate(self._value) else Nil()\ndef flatten(self: Some[O]) -&gt; O:\n\"\"\"Converts from `Option[Option[T]]` to `Option[T]`.\n        Examples:\n            &gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n            &gt;&gt;&gt; assert Some(nil).flatten() == nil\n            &gt;&gt;&gt; assert nil.flatten() == nil\n        \"\"\"\nif isinstance(self._value, (Some, Nil)):\nreturn self._value\nelse:\nraise TypeError(f\"Cannot flatten type: Some({type(self._value).__name__})\")\ndef get_or_insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts value into the option if it is [nil][iterum.nil], then returns a\n        tuple of the resulting option and the returned value.\n        See also [insert][iterum.Some.insert], which updates the value even if\n        the option already contains a value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n            &gt;&gt;&gt; assert value == 5\n            &gt;&gt;&gt; assert opt == Some(5)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n            &gt;&gt;&gt; assert value == 3\n            &gt;&gt;&gt; assert opt == Some(3)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n            &gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n            &gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n            &gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n        \"\"\"\nreturn Swap(Some(self._value), self._value)\ndef get_or_insert_with(self, f: Callable[[], T], /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts a value computed from `f` into the option if it is\n        [nil][iterum.nil], then returns a tuple of the resulting option and the\n        returned value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert value == 5\n            &gt;&gt;&gt; assert opt == Some(5)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert value == 3\n            &gt;&gt;&gt; assert opt == Some(3)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert swap.inserted == Some(10)\n            &gt;&gt;&gt; assert swap.returned == 10\n            &gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n        \"\"\"\nreturn Swap(Some(self._value), self._value)\ndef insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts value into the option, then returns a tuple of the resulting\n        option and the returned value.\n        If the option already contains a value, the old value is dropped.\n        See also [get_or_insert][iterum.Some.get_or_insert], which doesn\u2019t\n        update the value if the option already contains a value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.insert(1)\n            &gt;&gt;&gt; assert value == 1\n            &gt;&gt;&gt; assert opt == Some(1)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.insert(1)\n            &gt;&gt;&gt; assert value == 1\n            &gt;&gt;&gt; assert opt == Some(1)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).insert(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n            &gt;&gt;&gt; swap = nil.insert(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n        \"\"\"\nself._value = value\nreturn Swap(Some(self._value), self._value)\ndef is_nil(self) -&gt; Literal[False]:\n\"\"\"Returns `True` if the option is a [nil][iterum.nil] value.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_nil() is False\n            &gt;&gt;&gt; assert nil.is_nil() is True\n        \"\"\"\nreturn False\ndef is_some(self) -&gt; Literal[True]:\n\"\"\"Returns `True` if the option is a Some value.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_some() is True\n            &gt;&gt;&gt; assert nil.is_some() is False\n        \"\"\"\nreturn True\ndef is_some_and(self, f: Callable[[T], object]) -&gt; bool:\n\"\"\"Returns `True` if the option is a [Some][iterum.Some] and the value\n        inside of it matches a predicate.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n            &gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n            &gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n        \"\"\"\nreturn bool(f(self.unwrap()))\ndef iter(self) -&gt; iterum[T]:\n\"\"\"Returns an iterator over the possibly contained value.\n        Examples:\n            &gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n            &gt;&gt;&gt; assert nil.iter().next() == nil\n        \"\"\"\nfrom ._iterum import iterum\nreturn iterum([self._value])\ndef map(self, f: Callable[[T], U], /) -&gt; Some[U]:\n\"\"\"Maps an [Option[T]][iterum.Option] to [Option[U]][iterum.Option] by\n        applying a function to a contained value (if [Some][iterum.Some]) or\n        returns [nil][iterum.nil] (if [Nil][iterum.Nil]).\n        Examples:\n            &gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n            &gt;&gt;&gt; assert nil.map(len) == nil\n        \"\"\"\nreturn Some(f(self._value))\ndef map_or(self, default: U, f: Callable[[T], U], /) -&gt; U:\n\"\"\"\n        Returns the provided default result (if [nil][iterum.nil]), or applies a\n        function to the contained value (if any).\n        Arguments passed to [map_or][iterum.Some.map_or] are eagerly evaluated;\n        if you are passing the result of a function call, it is recommended to\n        use [map_or_else][iterum.Some.map_or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n            &gt;&gt;&gt; assert nil.map_or(42, len) == 42\n        \"\"\"\nreturn f(self._value)\ndef map_or_else(self, default: Callable[[], U], f: Callable[[T], U], /) -&gt; U:\n\"\"\"\n        Computes a default function result (if [nil][iterum.nil]), or applies a\n        different function to the contained value (if any).\n        Examples:\n            &gt;&gt;&gt; k = 21\n            &gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n            &gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n        \"\"\"\nreturn f(self._value)\ndef ok_or(self, err: Exception, /) -&gt; T:\n\"\"\"Unwraps the option returning the value if [Some][iterum.Some] or raises\n        the provided exception if [nil][iterum.nil].\n        Arguments passed to [ok_or][iterum.Some.ok_or] are eagerly evaluated; if\n        you are passing the result of a function call, it is recommended to use\n        [ok_or_else][iterum.Some.ok_or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n            &gt;&gt;&gt; try:\n            ...     nil.ok_or(RuntimeError(\"oh no!\"))\n            ... except RuntimeError as ex:\n            ...     print(ex)\n            ...\n            oh no!\n        \"\"\"\nreturn self._value\ndef ok_or_else(self, err: Callable[[], Exception], /) -&gt; T:\n\"\"\"Unwraps the option returning the value if [Some][iterum.Some] or raises\n        the exception returned by the provided callable if [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n            &gt;&gt;&gt; try:\n            ...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n            ... except AssertionError as ex:\n            ...     print(ex)\n            ...\n            oopsy!\n        \"\"\"\nreturn self._value\ndef or_(self, optb: Option[T], /) -&gt; Some[T]:\n\"\"\"Returns the option if it contains a value, otherwise returns optb.\n        Arguments passed to [or_][iterum.Some.or_] are eagerly evaluated; if you\n        are passing the result of a function call, it is recommended to use\n        [or_else][iterum.Some.or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n            &gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n            &gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n            &gt;&gt;&gt; assert nil.or_(nil) == nil\n        Note: because `or` is a keyword, this method is called `or_` instead.\n        \"\"\"\n# 'or' is a keyword, so instead we use 'or_'\nreturn self\ndef or_else(self, f: Callable[[], Option[T]], /) -&gt; Some[T]:\n\"\"\"Returns the option if it contains a value, otherwise calls `f` and\n        returns the result.\n        Examples:\n            &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n            ...     return nil\n            ...\n            &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n            ...     return Some(\"vikings\")\n            ...\n            &gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n            &gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n            &gt;&gt;&gt; assert nil.or_else(nobody) == nil\n        \"\"\"\nreturn self\ndef replace(self, value: T, /) -&gt; Swap[Some[T], Some[T]]:\n\"\"\"Replaces the actual value in the option by the value given in parameter,\n        returning a tuple of the resulting option and the returned old value if\n        present.\n        Examples:\n            &gt;&gt;&gt; x = Some(2)\n            &gt;&gt;&gt; new, old = x.replace(5)\n            &gt;&gt;&gt; assert new == Some(5)\n            &gt;&gt;&gt; assert old == Some(2)\n            &gt;&gt;&gt; x = nil\n            &gt;&gt;&gt; new, old = x.replace(5)\n            &gt;&gt;&gt; assert new == Some(5)\n            &gt;&gt;&gt; assert old == nil\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).replace(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == Some(10)\n            &gt;&gt;&gt; swap = nil.replace(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == nil\n        \"\"\"\nold = self._value\nself._value = value\nreturn Swap(Some(self._value), Some(old))\ndef take(self) -&gt; Swap[Nil, Some[T]]:\n\"\"\"Takes the value out of the option, returning a tuple of the resulting\n        nil and the old option.\n        Examples:\n            &gt;&gt;&gt; x = Some(2)\n            &gt;&gt;&gt; new, old = x.take()\n            &gt;&gt;&gt; assert new == nil\n            &gt;&gt;&gt; assert old == Some(2)\n            &gt;&gt;&gt; x = nil\n            &gt;&gt;&gt; new, old = x.take()\n            &gt;&gt;&gt; assert new == nil\n            &gt;&gt;&gt; assert old == nil\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(2).take()\n            &gt;&gt;&gt; assert swap.inserted == nil\n            &gt;&gt;&gt; assert swap.returned == Some(2)\n            &gt;&gt;&gt; swap = nil.take()\n            &gt;&gt;&gt; assert swap.inserted == nil\n            &gt;&gt;&gt; assert swap.returned == nil\n        \"\"\"\nreturn Swap(nil, self)\n# transpose ... without a Result concept there isn't any value\ndef unwrap(self) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n            &gt;&gt;&gt; try:\n            ...     nil.unwrap()\n            ... except UnwrapNilError as ex:\n            ...     print(\"Attempted to unwrap a nil!\")\n            ...\n            Attempted to unwrap a nil!\n        Raises:\n            UnwrapNilError: if the value is a [nil][iterum.nil].\n        \"\"\"\nreturn self._value\ndef unwrap_or(self, default: T, /) -&gt; T:\n\"\"\"\n        Returns the contained [Some][iterum.Some] value or a provided default.\n        Arguments passed to [unwrap_or][iterum.Some.unwrap_or] are eagerly\n        evaluated; if you are passing the result of a function call, it is\n        recommended to use [unwrap_or_else][iterum.Some.unwrap_or_else], which\n        is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n            &gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n        \"\"\"\nreturn self._value\ndef unwrap_or_else(self, f: Callable[[], T], /) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value or computes it from a closure.\n        Examples:\n            &gt;&gt;&gt; k = 10\n            &gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n            &gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n        \"\"\"\nreturn self._value\ndef unzip(self: Some[tuple[U, V]]) -&gt; tuple[Some[U], Some[V]]:\n\"\"\"Unzips an option containing a tuple of two options.\n        If `self` is `Some((a, b))` this method returns `(Some(a), Some(b))`.\n        Otherwise, `(nil, nil)` is returned.\n        Examples:\n            &gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n            &gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n        \"\"\"\nleft, right = self._value\nreturn Some(left), Some(right)\n@overload\ndef xor(self, optb: Some[T], /) -&gt; Nil:\n...\n@overload\ndef xor(self, optb: Nil, /) -&gt; Some[T]:\n...\ndef xor(self, optb: Option[T], /) -&gt; Option[T]:\n\"\"\"\n        Returns [Some][iterum.Some] if exactly one of `self`, `optb` is\n        [Some][iterum.Some], otherwise returns [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n            &gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n            &gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n            &gt;&gt;&gt; assert nil.xor(nil) == nil\n        \"\"\"\nreturn self if isinstance(optb, Nil) else nil\n@overload\ndef zip(self, other: Some[U], /) -&gt; Some[tuple[T, U]]:\n...\n@overload\ndef zip(self, other: Nil, /) -&gt; Nil:\n...\ndef zip(self, other: Option[U], /) -&gt; Option[tuple[T, U]]:\n\"\"\"\n        Zips `self` with another option.\n        If `self` is `Some(s)` and `other` is `Some(o)`,\n        this method returns `Some((s, o))`.\n        Otherwise, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n            &gt;&gt;&gt; assert Some(1).zip(nil) == nil\n            &gt;&gt;&gt; assert nil.zip(nil) == nil\n        \"\"\"\nreturn nil if isinstance(other, Nil) else Some((self._value, other._value))\n</code></pre>"},{"location":"api/#iterum._option.Some.and_","title":"<code>and_(optb: O) -&gt; O</code>","text":"<p>Returns nil if the option is nil, otherwise returns optb.</p> <p>Arguments passed to and_ are eagerly evaluated; if you are passing the result of a function call, it is recommended to use and_then, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).and_(nil) == nil\n&gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n&gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n&gt;&gt;&gt; assert nil.and_(nil) == nil\n</code></pre> <p>Note: because <code>and</code> is a keyword, this method is called <code>and_</code> instead.</p> Source code in <code>iterum/_option.py</code> <pre><code>def and_(self, optb: O, /) -&gt; O:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    returns optb.\n    Arguments passed to [and_][iterum.Some.and_] are eagerly evaluated; if\n    you are passing the result of a function call, it is recommended to use\n    [and_then][iterum.Some.and_then], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).and_(nil) == nil\n        &gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n        &gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n        &gt;&gt;&gt; assert nil.and_(nil) == nil\n    Note: because `and` is a keyword, this method is called `and_` instead.\n    \"\"\"\nreturn optb\n</code></pre>"},{"location":"api/#iterum._option.Some.and_then","title":"<code>and_then(f: Callable[[T], O]) -&gt; O</code>","text":"<p>Returns nil if the option is nil, otherwise calls <code>f</code> with the wrapped value and returns the result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n&gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n...     sq = x * x\n...     if sq &gt; MAX_U32:\n...         return nil\n...     return Some(sq)\n...\n&gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n&gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n&gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def and_then(self, f: Callable[[T], O], /) -&gt; O:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    calls `f` with the wrapped value and returns the result.\n    Examples:\n        &gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n        &gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n        ...     sq = x * x\n        ...     if sq &gt; MAX_U32:\n        ...         return nil\n        ...     return Some(sq)\n        ...\n        &gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n        &gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n        &gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n    \"\"\"\nreturn f(self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.expect","title":"<code>expect(msg: str) -&gt; T</code>","text":"<p>Returns the contained Some value, consuming the self value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(\"value\")\n&gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.expect(\"fruits are healthy\")\n... except ExpectNilError as ex:\n...     print(ex)\n...\nfruits are healthy\n</code></pre> <p>Raises:</p> Type Description <code>ExpectNilError</code> <p>if the value is a nil with a custom message provided by msg.</p> Source code in <code>iterum/_option.py</code> <pre><code>def expect(self, msg: str, /) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value, consuming the self value.\n    Examples:\n        &gt;&gt;&gt; x = Some(\"value\")\n        &gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n        &gt;&gt;&gt; try:\n        ...     nil.expect(\"fruits are healthy\")\n        ... except ExpectNilError as ex:\n        ...     print(ex)\n        ...\n        fruits are healthy\n    Raises:\n        ExpectNilError: if the value is a [nil][iterum.nil] with a custom\n            message provided by msg.\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.filter","title":"<code>filter(predicate: Callable[[T], object]) -&gt; Option[T]</code>","text":"<p>Returns nil if the option is nil, otherwise calls <code>predicate</code> with the wrapped value and returns:</p> <pre><code>- [Some(value)][iterum.Some] if the predicate returns `True`\n- [nil][iterum.nil] if the predicate returns `False`\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n&gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n&gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def filter(self, predicate: Callable[[T], object], /) -&gt; Option[T]:\n\"\"\"Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    calls `predicate` with the wrapped value and returns:\n        - [Some(value)][iterum.Some] if the predicate returns `True`\n        - [nil][iterum.nil] if the predicate returns `False`\n    Examples:\n        &gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n        &gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n        &gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n    \"\"\"\nreturn self if predicate(self._value) else Nil()\n</code></pre>"},{"location":"api/#iterum._option.Some.flatten","title":"<code>flatten() -&gt; O</code>","text":"<p>Converts from <code>Option[Option[T]]</code> to <code>Option[T]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n&gt;&gt;&gt; assert Some(nil).flatten() == nil\n&gt;&gt;&gt; assert nil.flatten() == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def flatten(self: Some[O]) -&gt; O:\n\"\"\"Converts from `Option[Option[T]]` to `Option[T]`.\n    Examples:\n        &gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n        &gt;&gt;&gt; assert Some(nil).flatten() == nil\n        &gt;&gt;&gt; assert nil.flatten() == nil\n    \"\"\"\nif isinstance(self._value, (Some, Nil)):\nreturn self._value\nelse:\nraise TypeError(f\"Cannot flatten type: Some({type(self._value).__name__})\")\n</code></pre>"},{"location":"api/#iterum._option.Some.get_or_insert","title":"<code>get_or_insert(value: T) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts value into the option if it is nil, then returns a tuple of the resulting option and the returned value.</p> <p>See also insert, which updates the value even if the option already contains a value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n&gt;&gt;&gt; assert value == 5\n&gt;&gt;&gt; assert opt == Some(5)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n&gt;&gt;&gt; assert value == 3\n&gt;&gt;&gt; assert opt == Some(3)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n&gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n</code></pre> <pre><code>&gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n&gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def get_or_insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts value into the option if it is [nil][iterum.nil], then returns a\n    tuple of the resulting option and the returned value.\n    See also [insert][iterum.Some.insert], which updates the value even if\n    the option already contains a value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n        &gt;&gt;&gt; assert value == 5\n        &gt;&gt;&gt; assert opt == Some(5)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n        &gt;&gt;&gt; assert value == 3\n        &gt;&gt;&gt; assert opt == Some(3)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n        &gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n        &gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n        &gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n    \"\"\"\nreturn Swap(Some(self._value), self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.get_or_insert_with","title":"<code>get_or_insert_with(f: Callable[[], T]) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts a value computed from <code>f</code> into the option if it is nil, then returns a tuple of the resulting option and the returned value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert value == 5\n&gt;&gt;&gt; assert opt == Some(5)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert value == 3\n&gt;&gt;&gt; assert opt == Some(3)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert swap.inserted == Some(10)\n&gt;&gt;&gt; assert swap.returned == 10\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def get_or_insert_with(self, f: Callable[[], T], /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts a value computed from `f` into the option if it is\n    [nil][iterum.nil], then returns a tuple of the resulting option and the\n    returned value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert value == 5\n        &gt;&gt;&gt; assert opt == Some(5)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert value == 3\n        &gt;&gt;&gt; assert opt == Some(3)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert swap.inserted == Some(10)\n        &gt;&gt;&gt; assert swap.returned == 10\n        &gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n    \"\"\"\nreturn Swap(Some(self._value), self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.insert","title":"<code>insert(value: T) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts value into the option, then returns a tuple of the resulting option and the returned value.</p> <p>If the option already contains a value, the old value is dropped.</p> <p>See also get_or_insert, which doesn\u2019t update the value if the option already contains a value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.insert(1)\n&gt;&gt;&gt; assert value == 1\n&gt;&gt;&gt; assert opt == Some(1)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.insert(1)\n&gt;&gt;&gt; assert value == 1\n&gt;&gt;&gt; assert opt == Some(1)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).insert(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.insert(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"Inserts value into the option, then returns a tuple of the resulting\n    option and the returned value.\n    If the option already contains a value, the old value is dropped.\n    See also [get_or_insert][iterum.Some.get_or_insert], which doesn\u2019t\n    update the value if the option already contains a value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.insert(1)\n        &gt;&gt;&gt; assert value == 1\n        &gt;&gt;&gt; assert opt == Some(1)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.insert(1)\n        &gt;&gt;&gt; assert value == 1\n        &gt;&gt;&gt; assert opt == Some(1)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).insert(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n        &gt;&gt;&gt; swap = nil.insert(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n    \"\"\"\nself._value = value\nreturn Swap(Some(self._value), self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.is_nil","title":"<code>is_nil() -&gt; Literal[False]</code>","text":"<p>Returns <code>True</code> if the option is a nil value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_nil() is False\n&gt;&gt;&gt; assert nil.is_nil() is True\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_nil(self) -&gt; Literal[False]:\n\"\"\"Returns `True` if the option is a [nil][iterum.nil] value.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_nil() is False\n        &gt;&gt;&gt; assert nil.is_nil() is True\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"api/#iterum._option.Some.is_some","title":"<code>is_some() -&gt; Literal[True]</code>","text":"<p>Returns <code>True</code> if the option is a Some value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_some() is True\n&gt;&gt;&gt; assert nil.is_some() is False\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_some(self) -&gt; Literal[True]:\n\"\"\"Returns `True` if the option is a Some value.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_some() is True\n        &gt;&gt;&gt; assert nil.is_some() is False\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"api/#iterum._option.Some.is_some_and","title":"<code>is_some_and(f: Callable[[T], object]) -&gt; bool</code>","text":"<p>Returns <code>True</code> if the option is a Some and the value inside of it matches a predicate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n&gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n&gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_some_and(self, f: Callable[[T], object]) -&gt; bool:\n\"\"\"Returns `True` if the option is a [Some][iterum.Some] and the value\n    inside of it matches a predicate.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n        &gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n        &gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n    \"\"\"\nreturn bool(f(self.unwrap()))\n</code></pre>"},{"location":"api/#iterum._option.Some.iter","title":"<code>iter() -&gt; iterum[T]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n&gt;&gt;&gt; assert nil.iter().next() == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def iter(self) -&gt; iterum[T]:\n\"\"\"Returns an iterator over the possibly contained value.\n    Examples:\n        &gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n        &gt;&gt;&gt; assert nil.iter().next() == nil\n    \"\"\"\nfrom ._iterum import iterum\nreturn iterum([self._value])\n</code></pre>"},{"location":"api/#iterum._option.Some.map","title":"<code>map(f: Callable[[T], U]) -&gt; Some[U]</code>","text":"<p>Maps an Option[T] to Option[U] by applying a function to a contained value (if Some) or returns nil (if Nil).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n&gt;&gt;&gt; assert nil.map(len) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map(self, f: Callable[[T], U], /) -&gt; Some[U]:\n\"\"\"Maps an [Option[T]][iterum.Option] to [Option[U]][iterum.Option] by\n    applying a function to a contained value (if [Some][iterum.Some]) or\n    returns [nil][iterum.nil] (if [Nil][iterum.Nil]).\n    Examples:\n        &gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n        &gt;&gt;&gt; assert nil.map(len) == nil\n    \"\"\"\nreturn Some(f(self._value))\n</code></pre>"},{"location":"api/#iterum._option.Some.map_or","title":"<code>map_or(default: U, f: Callable[[T], U]) -&gt; U</code>","text":"<p>Returns the provided default result (if nil), or applies a function to the contained value (if any).</p> <p>Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use map_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n&gt;&gt;&gt; assert nil.map_or(42, len) == 42\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map_or(self, default: U, f: Callable[[T], U], /) -&gt; U:\n\"\"\"\n    Returns the provided default result (if [nil][iterum.nil]), or applies a\n    function to the contained value (if any).\n    Arguments passed to [map_or][iterum.Some.map_or] are eagerly evaluated;\n    if you are passing the result of a function call, it is recommended to\n    use [map_or_else][iterum.Some.map_or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n        &gt;&gt;&gt; assert nil.map_or(42, len) == 42\n    \"\"\"\nreturn f(self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.map_or_else","title":"<code>map_or_else(default: Callable[[], U], f: Callable[[T], U]) -&gt; U</code>","text":"<p>Computes a default function result (if nil), or applies a different function to the contained value (if any).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; k = 21\n&gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n&gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map_or_else(self, default: Callable[[], U], f: Callable[[T], U], /) -&gt; U:\n\"\"\"\n    Computes a default function result (if [nil][iterum.nil]), or applies a\n    different function to the contained value (if any).\n    Examples:\n        &gt;&gt;&gt; k = 21\n        &gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n        &gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n    \"\"\"\nreturn f(self._value)\n</code></pre>"},{"location":"api/#iterum._option.Some.ok_or","title":"<code>ok_or(err: Exception) -&gt; T</code>","text":"<p>Unwraps the option returning the value if Some or raises the provided exception if nil.</p> <p>Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.ok_or(RuntimeError(\"oh no!\"))\n... except RuntimeError as ex:\n...     print(ex)\n...\noh no!\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def ok_or(self, err: Exception, /) -&gt; T:\n\"\"\"Unwraps the option returning the value if [Some][iterum.Some] or raises\n    the provided exception if [nil][iterum.nil].\n    Arguments passed to [ok_or][iterum.Some.ok_or] are eagerly evaluated; if\n    you are passing the result of a function call, it is recommended to use\n    [ok_or_else][iterum.Some.ok_or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n        &gt;&gt;&gt; try:\n        ...     nil.ok_or(RuntimeError(\"oh no!\"))\n        ... except RuntimeError as ex:\n        ...     print(ex)\n        ...\n        oh no!\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.ok_or_else","title":"<code>ok_or_else(err: Callable[[], Exception]) -&gt; T</code>","text":"<p>Unwraps the option returning the value if Some or raises the exception returned by the provided callable if nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n... except AssertionError as ex:\n...     print(ex)\n...\noopsy!\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def ok_or_else(self, err: Callable[[], Exception], /) -&gt; T:\n\"\"\"Unwraps the option returning the value if [Some][iterum.Some] or raises\n    the exception returned by the provided callable if [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n        &gt;&gt;&gt; try:\n        ...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n        ... except AssertionError as ex:\n        ...     print(ex)\n        ...\n        oopsy!\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.or_","title":"<code>or_(optb: Option[T]) -&gt; Some[T]</code>","text":"<p>Returns the option if it contains a value, otherwise returns optb.</p> <p>Arguments passed to or_ are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n&gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n&gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n&gt;&gt;&gt; assert nil.or_(nil) == nil\n</code></pre> <p>Note: because <code>or</code> is a keyword, this method is called <code>or_</code> instead.</p> Source code in <code>iterum/_option.py</code> <pre><code>def or_(self, optb: Option[T], /) -&gt; Some[T]:\n\"\"\"Returns the option if it contains a value, otherwise returns optb.\n    Arguments passed to [or_][iterum.Some.or_] are eagerly evaluated; if you\n    are passing the result of a function call, it is recommended to use\n    [or_else][iterum.Some.or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n        &gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n        &gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n        &gt;&gt;&gt; assert nil.or_(nil) == nil\n    Note: because `or` is a keyword, this method is called `or_` instead.\n    \"\"\"\n# 'or' is a keyword, so instead we use 'or_'\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Some.or_else","title":"<code>or_else(f: Callable[[], Option[T]]) -&gt; Some[T]</code>","text":"<p>Returns the option if it contains a value, otherwise calls <code>f</code> and returns the result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def nobody() -&gt; Option[str]:\n...     return nil\n...\n&gt;&gt;&gt; def vikings() -&gt; Option[str]:\n...     return Some(\"vikings\")\n...\n&gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n&gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n&gt;&gt;&gt; assert nil.or_else(nobody) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def or_else(self, f: Callable[[], Option[T]], /) -&gt; Some[T]:\n\"\"\"Returns the option if it contains a value, otherwise calls `f` and\n    returns the result.\n    Examples:\n        &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n        ...     return nil\n        ...\n        &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n        ...     return Some(\"vikings\")\n        ...\n        &gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n        &gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n        &gt;&gt;&gt; assert nil.or_else(nobody) == nil\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Some.replace","title":"<code>replace(value: T) -&gt; Swap[Some[T], Some[T]]</code>","text":"<p>Replaces the actual value in the option by the value given in parameter, returning a tuple of the resulting option and the returned old value if present.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(2)\n&gt;&gt;&gt; new, old = x.replace(5)\n&gt;&gt;&gt; assert new == Some(5)\n&gt;&gt;&gt; assert old == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; x = nil\n&gt;&gt;&gt; new, old = x.replace(5)\n&gt;&gt;&gt; assert new == Some(5)\n&gt;&gt;&gt; assert old == nil\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).replace(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == Some(10)\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.replace(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def replace(self, value: T, /) -&gt; Swap[Some[T], Some[T]]:\n\"\"\"Replaces the actual value in the option by the value given in parameter,\n    returning a tuple of the resulting option and the returned old value if\n    present.\n    Examples:\n        &gt;&gt;&gt; x = Some(2)\n        &gt;&gt;&gt; new, old = x.replace(5)\n        &gt;&gt;&gt; assert new == Some(5)\n        &gt;&gt;&gt; assert old == Some(2)\n        &gt;&gt;&gt; x = nil\n        &gt;&gt;&gt; new, old = x.replace(5)\n        &gt;&gt;&gt; assert new == Some(5)\n        &gt;&gt;&gt; assert old == nil\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).replace(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == Some(10)\n        &gt;&gt;&gt; swap = nil.replace(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == nil\n    \"\"\"\nold = self._value\nself._value = value\nreturn Swap(Some(self._value), Some(old))\n</code></pre>"},{"location":"api/#iterum._option.Some.take","title":"<code>take() -&gt; Swap[Nil, Some[T]]</code>","text":"<p>Takes the value out of the option, returning a tuple of the resulting nil and the old option.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(2)\n&gt;&gt;&gt; new, old = x.take()\n&gt;&gt;&gt; assert new == nil\n&gt;&gt;&gt; assert old == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; x = nil\n&gt;&gt;&gt; new, old = x.take()\n&gt;&gt;&gt; assert new == nil\n&gt;&gt;&gt; assert old == nil\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(2).take()\n&gt;&gt;&gt; assert swap.inserted == nil\n&gt;&gt;&gt; assert swap.returned == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.take()\n&gt;&gt;&gt; assert swap.inserted == nil\n&gt;&gt;&gt; assert swap.returned == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def take(self) -&gt; Swap[Nil, Some[T]]:\n\"\"\"Takes the value out of the option, returning a tuple of the resulting\n    nil and the old option.\n    Examples:\n        &gt;&gt;&gt; x = Some(2)\n        &gt;&gt;&gt; new, old = x.take()\n        &gt;&gt;&gt; assert new == nil\n        &gt;&gt;&gt; assert old == Some(2)\n        &gt;&gt;&gt; x = nil\n        &gt;&gt;&gt; new, old = x.take()\n        &gt;&gt;&gt; assert new == nil\n        &gt;&gt;&gt; assert old == nil\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(2).take()\n        &gt;&gt;&gt; assert swap.inserted == nil\n        &gt;&gt;&gt; assert swap.returned == Some(2)\n        &gt;&gt;&gt; swap = nil.take()\n        &gt;&gt;&gt; assert swap.inserted == nil\n        &gt;&gt;&gt; assert swap.returned == nil\n    \"\"\"\nreturn Swap(nil, self)\n</code></pre>"},{"location":"api/#iterum._option.Some.unwrap","title":"<code>unwrap() -&gt; T</code>","text":"<p>Returns the contained Some value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.unwrap()\n... except UnwrapNilError as ex:\n...     print(\"Attempted to unwrap a nil!\")\n...\nAttempted to unwrap a nil!\n</code></pre> <p>Raises:</p> Type Description <code>UnwrapNilError</code> <p>if the value is a nil.</p> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap(self) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n        &gt;&gt;&gt; try:\n        ...     nil.unwrap()\n        ... except UnwrapNilError as ex:\n        ...     print(\"Attempted to unwrap a nil!\")\n        ...\n        Attempted to unwrap a nil!\n    Raises:\n        UnwrapNilError: if the value is a [nil][iterum.nil].\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained Some value or a provided default.</p> <p>Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n&gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap_or(self, default: T, /) -&gt; T:\n\"\"\"\n    Returns the contained [Some][iterum.Some] value or a provided default.\n    Arguments passed to [unwrap_or][iterum.Some.unwrap_or] are eagerly\n    evaluated; if you are passing the result of a function call, it is\n    recommended to use [unwrap_or_else][iterum.Some.unwrap_or_else], which\n    is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n        &gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.unwrap_or_else","title":"<code>unwrap_or_else(f: Callable[[], T]) -&gt; T</code>","text":"<p>Returns the contained Some value or computes it from a closure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; k = 10\n&gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n&gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap_or_else(self, f: Callable[[], T], /) -&gt; T:\n\"\"\"Returns the contained [Some][iterum.Some] value or computes it from a closure.\n    Examples:\n        &gt;&gt;&gt; k = 10\n        &gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n        &gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n    \"\"\"\nreturn self._value\n</code></pre>"},{"location":"api/#iterum._option.Some.unzip","title":"<code>unzip() -&gt; tuple[Some[U], Some[V]]</code>","text":"<p>Unzips an option containing a tuple of two options.</p> <p>If <code>self</code> is <code>Some((a, b))</code> this method returns <code>(Some(a), Some(b))</code>. Otherwise, <code>(nil, nil)</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n&gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unzip(self: Some[tuple[U, V]]) -&gt; tuple[Some[U], Some[V]]:\n\"\"\"Unzips an option containing a tuple of two options.\n    If `self` is `Some((a, b))` this method returns `(Some(a), Some(b))`.\n    Otherwise, `(nil, nil)` is returned.\n    Examples:\n        &gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n        &gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n    \"\"\"\nleft, right = self._value\nreturn Some(left), Some(right)\n</code></pre>"},{"location":"api/#iterum._option.Some.xor","title":"<code>xor(optb: Option[T]) -&gt; Option[T]</code>","text":"<p>Returns Some if exactly one of <code>self</code>, <code>optb</code> is Some, otherwise returns nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n&gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n&gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n&gt;&gt;&gt; assert nil.xor(nil) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def xor(self, optb: Option[T], /) -&gt; Option[T]:\n\"\"\"\n    Returns [Some][iterum.Some] if exactly one of `self`, `optb` is\n    [Some][iterum.Some], otherwise returns [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n        &gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n        &gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n        &gt;&gt;&gt; assert nil.xor(nil) == nil\n    \"\"\"\nreturn self if isinstance(optb, Nil) else nil\n</code></pre>"},{"location":"api/#iterum._option.Some.zip","title":"<code>zip(other: Option[U]) -&gt; Option[tuple[T, U]]</code>","text":"<p>Zips <code>self</code> with another option.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>other</code> is <code>Some(o)</code>, this method returns <code>Some((s, o))</code>. Otherwise, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n&gt;&gt;&gt; assert Some(1).zip(nil) == nil\n&gt;&gt;&gt; assert nil.zip(nil) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def zip(self, other: Option[U], /) -&gt; Option[tuple[T, U]]:\n\"\"\"\n    Zips `self` with another option.\n    If `self` is `Some(s)` and `other` is `Some(o)`,\n    this method returns `Some((s, o))`.\n    Otherwise, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n        &gt;&gt;&gt; assert Some(1).zip(nil) == nil\n        &gt;&gt;&gt; assert nil.zip(nil) == nil\n    \"\"\"\nreturn nil if isinstance(other, Nil) else Some((self._value, other._value))\n</code></pre>"},{"location":"api/#iterum.Nil","title":"<code>iterum.Nil</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Nil has no value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Nil()  # Type of \"x\" is \"Nil\"\n&gt;&gt;&gt; x\nnil\n&gt;&gt;&gt; x.is_nil()\nTrue\n</code></pre> <p>Nil always returns the same object so just use nil instead.</p> <pre><code>&gt;&gt;&gt; nil is Nil()\nTrue\n</code></pre> <p>Likely, the only practical use of the Nil class is for type annotations and calls to <code>isinstance</code>.</p> Source code in <code>iterum/_option.py</code> <pre><code>class Nil(Singleton):\n\"\"\"\n    [Nil][iterum.Nil] has no value.\n    Examples:\n        &gt;&gt;&gt; x = Nil()  # Type of \"x\" is \"Nil\"\n        &gt;&gt;&gt; x\n        nil\n        &gt;&gt;&gt; x.is_nil()\n        True\n    [Nil][iterum.Nil] always returns the same object so just use [nil][iterum.nil] instead.\n        &gt;&gt;&gt; nil is Nil()\n        True\n    Likely, the only practical use of the [Nil][iterum.Nil] class is for type annotations and calls to `isinstance`.\n    \"\"\"\n__slots__ = ()\ndef __repr__(self) -&gt; str:\nreturn \"nil\"\ndef __bool__(self) -&gt; Literal[False]:\nreturn False\ndef and_(self, optb: Option[U], /) -&gt; Nil:\n\"\"\"\n        Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        returns optb.\n        Arguments passed to [and_][iterum.Nil.and_] are eagerly evaluated; if\n        you are passing the result of a function call, it is recommended to use\n        [and_then][iterum.Nil.and_then], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).and_(nil) == nil\n            &gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n            &gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n            &gt;&gt;&gt; assert nil.and_(nil) == nil\n        Note: because `and` is a keyword, this method is called `and_` instead.\n        \"\"\"\n# 'and' is a keyword, so instead we use 'and_'\nreturn self\ndef and_then(self, f: Callable[[Any], Option[U]], /) -&gt; Nil:\n\"\"\"\n        Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        calls `f` with the wrapped value and returns the result.\n        Examples:\n            &gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n            &gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n            ...     sq = x * x\n            ...     if sq &gt; MAX_U32:\n            ...         return nil\n            ...     return Some(sq)\n            ...\n            &gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n            &gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n            &gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n        \"\"\"\nreturn self\ndef expect(self, msg: str, /) -&gt; NoReturn:\n\"\"\"\n        Returns the contained [Some][iterum.Some] value, consuming the self value.\n        Examples:\n            &gt;&gt;&gt; x = Some(\"value\")\n            &gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n            &gt;&gt;&gt; try:\n            ...     nil.expect(\"fruits are healthy\")\n            ... except ExpectNilError as ex:\n            ...     print(ex)\n            ...\n            fruits are healthy\n        Raises:\n            ExpectNilError: if the value is a [nil][iterum.nil] with a custom\n                panic message provided by msg.\n        \"\"\"\nraise ExpectNilError(msg)\ndef filter(self, predicate: Callable[[Any], object], /) -&gt; Nil:\n\"\"\"\n        Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n        calls `predicate` with the wrapped value and returns:\n            - [Some(value)][iterum.Some] if the predicate returns `True`\n            - [nil][iterum.nil] if the predicate returns `False`\n        Examples:\n            &gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n            &gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n            &gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n        \"\"\"\nreturn self\ndef flatten(self) -&gt; Nil:\n\"\"\"\n        Converts from `Option[Option[T]]` to `Option[T]`.\n        Examples:\n            &gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n            &gt;&gt;&gt; assert Some(nil).flatten() == nil\n            &gt;&gt;&gt; assert nil.flatten() == nil\n        \"\"\"\nreturn self\ndef get_or_insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"\n        Inserts value into the option if it is [nil][iterum.nil], then returns a\n        tuple of the resulting option and the returned value.\n        See also [insert][iterum.Nil.insert], which updates the value even if\n        the option already contains a value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n            &gt;&gt;&gt; assert value == 5\n            &gt;&gt;&gt; assert opt == Some(5)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n            &gt;&gt;&gt; assert value == 3\n            &gt;&gt;&gt; assert opt == Some(3)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n            &gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n            &gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n            &gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n        \"\"\"\nreturn Swap(Some(value), value)\ndef get_or_insert_with(self, f: Callable[[], T], /) -&gt; Swap[Some[T], T]:\n\"\"\"\n        Inserts a value computed from `f` into the option if it is\n        [nil][iterum.nil], then returns a tuple of the resulting option and the\n        returned value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert value == 5\n            &gt;&gt;&gt; assert opt == Some(5)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert value == 3\n            &gt;&gt;&gt; assert opt == Some(3)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert swap.inserted == Some(10)\n            &gt;&gt;&gt; assert swap.returned == 10\n            &gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n        \"\"\"\nreturn Swap(Some(value := f()), value)\ndef insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"\n        Inserts value into the option, then returns a tuple of the resulting\n        option and the returned value.\n        If the option already contains a value, the old value is dropped.\n        See also [get_or_insert][iterum.Nil.get_or_insert], which doesn\u2019t\n        update the value if the option already contains a value.\n        Examples:\n            &gt;&gt;&gt; opt = nil\n            &gt;&gt;&gt; opt, value = opt.insert(1)\n            &gt;&gt;&gt; assert value == 1\n            &gt;&gt;&gt; assert opt == Some(1)\n            &gt;&gt;&gt; opt = Some(3)\n            &gt;&gt;&gt; opt, value = opt.insert(1)\n            &gt;&gt;&gt; assert value == 1\n            &gt;&gt;&gt; assert opt == Some(1)\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).insert(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n            &gt;&gt;&gt; swap = nil.insert(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == 5\n        \"\"\"\nreturn Swap(Some(value), value)\ndef is_nil(self) -&gt; Literal[True]:\n\"\"\"\n        Returns `True` if the option is a [nil][iterum.nil] value.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_nil() is False\n            &gt;&gt;&gt; assert nil.is_nil() is True\n        \"\"\"\nreturn True\ndef is_some(self) -&gt; Literal[False]:\n\"\"\"\n        Returns `True` if the option is a Some value.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_some() is True\n            &gt;&gt;&gt; assert nil.is_some() is False\n        \"\"\"\nreturn False\ndef is_some_and(self, f: Callable[[Any], object]) -&gt; Literal[False]:\n\"\"\"\n        Returns `True` if the option is a [Some][iterum.Some] and the value\n        inside of it matches a predicate.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n            &gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n            &gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n        \"\"\"\nreturn False\ndef iter(self) -&gt; iterum[Any]:\n\"\"\"\n        Returns an iterator over the possibly contained value.\n        Examples:\n            &gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n            &gt;&gt;&gt; assert nil.iter().next() == nil\n        \"\"\"\nfrom ._iterum import iterum\nreturn iterum([])\ndef map(self, f: Callable[[Any], Any], /) -&gt; Nil:\n\"\"\"\n        Maps an [Option[T]][iterum.Option] to [Option[U]][iterum.Option] by\n        applying a function to a contained value (if [Some][iterum.Some]) or\n        returns [nil][iterum.nil] (if [Nil][iterum.Nil]).\n        Examples:\n            &gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n            &gt;&gt;&gt; assert nil.map(len) == nil\n        \"\"\"\nreturn self\ndef map_or(self, default: U, f: Callable[[Any], U], /) -&gt; U:\n\"\"\"\n        Returns the provided default result (if [nil][iterum.nil]), or applies a\n        function to the contained value (if any).\n        Arguments passed to [map_or][iterum.Nil.map_or] are eagerly evaluated;\n        if you are passing the result of a function call, it is recommended to\n        use [map_or_else][iterum.Nil.map_or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n            &gt;&gt;&gt; assert nil.map_or(42, len) == 42\n        \"\"\"\nreturn default\ndef map_or_else(self, default: Callable[[], U], f: Callable[[Any], U], /) -&gt; U:\n\"\"\"\n        Computes a default function result (if [nil][iterum.nil]), or applies a\n        different function to the contained value (if any).\n        Examples:\n            &gt;&gt;&gt; k = 21\n            &gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n            &gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n        \"\"\"\nreturn default()\ndef ok_or(self, err: Exception, /) -&gt; NoReturn:\n\"\"\"\n        Unwraps the option returning the value if [Some][iterum.Some] or raises\n        the provided exception if [nil][iterum.nil].\n        Arguments passed to [ok_or][iterum.Nil.ok_or] are eagerly evaluated; if\n        you are passing the result of a function call, it is recommended to use\n        [ok_or_else][iterum.Nil.ok_or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n            &gt;&gt;&gt; try:\n            ...     nil.ok_or(RuntimeError(\"oh no!\"))\n            ... except RuntimeError as ex:\n            ...     print(ex)\n            ...\n            oh no!\n        \"\"\"\nraise err\ndef ok_or_else(self, err: Callable[[], Exception], /) -&gt; NoReturn:\n\"\"\"\n        Unwraps the option returning the value if [Some][iterum.Some] or raises\n        the exception returned by the provided callable if [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n            &gt;&gt;&gt; try:\n            ...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n            ... except AssertionError as ex:\n            ...     print(ex)\n            ...\n            oopsy!\n        \"\"\"\nraise err()\ndef or_(self, optb: O, /) -&gt; O:\n\"\"\"\n        Returns the option if it contains a value, otherwise returns optb.\n        Arguments passed to [or_][iterum.Nil.or_] are eagerly evaluated; if you\n        are passing the result of a function call, it is recommended to use\n        [or_else][iterum.Nil.or_else], which is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n            &gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n            &gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n            &gt;&gt;&gt; assert nil.or_(nil) == nil\n        Note: because `or` is a keyword, this method is called `or_` instead.\n        \"\"\"\n# 'or' is a keyword, so instead we use 'or_'\nreturn optb\ndef or_else(self, f: Callable[[], O], /) -&gt; O:\n\"\"\"\n        Returns the option if it contains a value, otherwise calls `f` and\n        returns the result.\n        Examples:\n            &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n            ...     return nil\n            ...\n            &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n            ...     return Some(\"vikings\")\n            ...\n            &gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n            &gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n            &gt;&gt;&gt; assert nil.or_else(nobody) == nil\n        \"\"\"\nreturn f()\ndef replace(self, value: T, /) -&gt; Swap[Some[T], Nil]:\n\"\"\"\n        Replaces the actual value in the option by the value given in parameter,\n        returning a tuple of the resulting option and the returned old value if\n        present.\n        Examples:\n            &gt;&gt;&gt; x = Some(2)\n            &gt;&gt;&gt; new, old = x.replace(5)\n            &gt;&gt;&gt; assert new == Some(5)\n            &gt;&gt;&gt; assert old == Some(2)\n            &gt;&gt;&gt; x = nil\n            &gt;&gt;&gt; new, old = x.replace(5)\n            &gt;&gt;&gt; assert new == Some(5)\n            &gt;&gt;&gt; assert old == nil\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(10).replace(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == Some(10)\n            &gt;&gt;&gt; swap = nil.replace(5)\n            &gt;&gt;&gt; assert swap.inserted == Some(5)\n            &gt;&gt;&gt; assert swap.returned == nil\n        \"\"\"\nreturn Swap(Some(value), nil)\ndef take(self) -&gt; Swap[Nil, Nil]:\n\"\"\"\n        Takes the value out of the option, returning a tuple of the resulting\n        nil and the old option.\n        Examples:\n            &gt;&gt;&gt; x = Some(2)\n            &gt;&gt;&gt; new, old = x.take()\n            &gt;&gt;&gt; assert new == nil\n            &gt;&gt;&gt; assert old == Some(2)\n            &gt;&gt;&gt; x = nil\n            &gt;&gt;&gt; new, old = x.take()\n            &gt;&gt;&gt; assert new == nil\n            &gt;&gt;&gt; assert old == nil\n            Alternatively, access the named attributes of [Swap][iterum.Swap],\n            [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n            &gt;&gt;&gt; swap = Some(2).take()\n            &gt;&gt;&gt; assert swap.inserted == nil\n            &gt;&gt;&gt; assert swap.returned == Some(2)\n            &gt;&gt;&gt; swap = nil.take()\n            &gt;&gt;&gt; assert swap.inserted == nil\n            &gt;&gt;&gt; assert swap.returned == nil\n        \"\"\"\nreturn Swap(nil, self)\n# transpose ... without a Result concept there isn't any value\ndef unwrap(self) -&gt; NoReturn:\n\"\"\"\n        Returns the contained [Some][iterum.Some] value.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n            &gt;&gt;&gt; try:\n            ...     nil.unwrap()\n            ... except UnwrapNilError as ex:\n            ...     print(\"Attempted to unwrap a nil!\")\n            ...\n            Attempted to unwrap a nil!\n        Raises:\n            UnwrapNilError: if the value is a [nil][iterum.nil].\n        \"\"\"\nraise UnwrapNilError()\ndef unwrap_or(self, default: T, /) -&gt; T:\n\"\"\"\n        Returns the contained [Some][iterum.Some] value or a provided default.\n        Arguments passed to [unwrap_or][iterum.Nil.unwrap_or] are eagerly\n        evaluated; if you are passing the result of a function call, it is\n        recommended to use [unwrap_or_else][iterum.Nil.unwrap_or_else], which\n        is lazily evaluated.\n        Examples:\n            &gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n            &gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n        \"\"\"\nreturn default\n# In order for unwrap_or_default to be implemented we would\n# need to know within nil what type we are supposed to have.\n#\n# If this was known we could come up with reasonable defaults, e.g. 0, {}, [], \"\", ...\n# note: these also happen to be what constructing the type with no params gives.\n#\n# If I wanted to get real fancy could provide user way to register defaults\n# for their custom types.\ndef unwrap_or_else(self, f: Callable[[], T], /) -&gt; T:\n\"\"\"\n        Returns the contained [Some][iterum.Some] value or computes it from a closure.\n        Examples:\n            &gt;&gt;&gt; k = 10\n            &gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n            &gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n        \"\"\"\nreturn f()\ndef unzip(self) -&gt; tuple[Nil, Nil]:\n\"\"\"\n        Unzips an option containing a tuple of two options.\n        If `self` is `Some((a, b))` this method returns `(Some(a), Some(b))`.\n        Otherwise, `(nil, nil)` is returned.\n        Examples:\n            &gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n            &gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n        \"\"\"\nreturn (nil, nil)\n@overload\ndef xor(self, optb: S, /) -&gt; S:\n...\n@overload\ndef xor(self, optb: Nil, /) -&gt; Nil:\n...\ndef xor(self, optb: O, /) -&gt; O | Nil:\n\"\"\"\n        Returns [Some][iterum.Some] if exactly one of `self`, `optb` is\n        [Some][iterum.Some], otherwise returns [nil][iterum.nil].\n        Examples:\n            &gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n            &gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n            &gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n            &gt;&gt;&gt; assert nil.xor(nil) == nil\n        \"\"\"\nreturn nil if isinstance(optb, Nil) else optb\ndef zip(self, other: Option[U], /) -&gt; Nil:\n\"\"\"\n        Zips `self` with another option.\n        If `self` is `Some(s)` and `other` is `Some(o)`,\n        this method returns `Some((s, o))`.\n        Otherwise, [nil][iterum.nil] is returned.\n        Examples:\n            &gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n            &gt;&gt;&gt; assert Some(1).zip(nil) == nil\n            &gt;&gt;&gt; assert nil.zip(nil) == nil\n        \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.and_","title":"<code>and_(optb: Option[U]) -&gt; Nil</code>","text":"<p>Returns nil if the option is nil, otherwise returns optb.</p> <p>Arguments passed to and_ are eagerly evaluated; if you are passing the result of a function call, it is recommended to use and_then, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).and_(nil) == nil\n&gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n&gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n&gt;&gt;&gt; assert nil.and_(nil) == nil\n</code></pre> <p>Note: because <code>and</code> is a keyword, this method is called <code>and_</code> instead.</p> Source code in <code>iterum/_option.py</code> <pre><code>def and_(self, optb: Option[U], /) -&gt; Nil:\n\"\"\"\n    Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    returns optb.\n    Arguments passed to [and_][iterum.Nil.and_] are eagerly evaluated; if\n    you are passing the result of a function call, it is recommended to use\n    [and_then][iterum.Nil.and_then], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).and_(nil) == nil\n        &gt;&gt;&gt; assert nil.and_(Some(\"foo\")) == nil\n        &gt;&gt;&gt; assert Some(2).and_(Some(\"foo\")) == Some(\"foo\")\n        &gt;&gt;&gt; assert nil.and_(nil) == nil\n    Note: because `and` is a keyword, this method is called `and_` instead.\n    \"\"\"\n# 'and' is a keyword, so instead we use 'and_'\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.and_then","title":"<code>and_then(f: Callable[[Any], Option[U]]) -&gt; Nil</code>","text":"<p>Returns nil if the option is nil, otherwise calls <code>f</code> with the wrapped value and returns the result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n&gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n...     sq = x * x\n...     if sq &gt; MAX_U32:\n...         return nil\n...     return Some(sq)\n...\n&gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n&gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n&gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def and_then(self, f: Callable[[Any], Option[U]], /) -&gt; Nil:\n\"\"\"\n    Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    calls `f` with the wrapped value and returns the result.\n    Examples:\n        &gt;&gt;&gt; MAX_U32 = (1 &lt;&lt; 32) - 1\n        &gt;&gt;&gt; def checked_sq_u32(x: int) -&gt; Option[int]:\n        ...     sq = x * x\n        ...     if sq &gt; MAX_U32:\n        ...         return nil\n        ...     return Some(sq)\n        ...\n        &gt;&gt;&gt; assert Some(2).and_then(checked_sq_u32) == Some(4)\n        &gt;&gt;&gt; assert Some(1_000_000).and_then(checked_sq_u32) == nil\n        &gt;&gt;&gt; assert nil.and_then(checked_sq_u32) == nil\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.expect","title":"<code>expect(msg: str) -&gt; NoReturn</code>","text":"<p>Returns the contained Some value, consuming the self value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(\"value\")\n&gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.expect(\"fruits are healthy\")\n... except ExpectNilError as ex:\n...     print(ex)\n...\nfruits are healthy\n</code></pre> <p>Raises:</p> Type Description <code>ExpectNilError</code> <p>if the value is a nil with a custom panic message provided by msg.</p> Source code in <code>iterum/_option.py</code> <pre><code>def expect(self, msg: str, /) -&gt; NoReturn:\n\"\"\"\n    Returns the contained [Some][iterum.Some] value, consuming the self value.\n    Examples:\n        &gt;&gt;&gt; x = Some(\"value\")\n        &gt;&gt;&gt; assert x.expect(\"fruits are healthy\") == \"value\"\n        &gt;&gt;&gt; try:\n        ...     nil.expect(\"fruits are healthy\")\n        ... except ExpectNilError as ex:\n        ...     print(ex)\n        ...\n        fruits are healthy\n    Raises:\n        ExpectNilError: if the value is a [nil][iterum.nil] with a custom\n            panic message provided by msg.\n    \"\"\"\nraise ExpectNilError(msg)\n</code></pre>"},{"location":"api/#iterum._option.Nil.filter","title":"<code>filter(predicate: Callable[[Any], object]) -&gt; Nil</code>","text":"<p>Returns nil if the option is nil, otherwise calls <code>predicate</code> with the wrapped value and returns:</p> <pre><code>- [Some(value)][iterum.Some] if the predicate returns `True`\n- [nil][iterum.nil] if the predicate returns `False`\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n&gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n&gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def filter(self, predicate: Callable[[Any], object], /) -&gt; Nil:\n\"\"\"\n    Returns [nil][iterum.nil] if the option is [nil][iterum.nil], otherwise\n    calls `predicate` with the wrapped value and returns:\n        - [Some(value)][iterum.Some] if the predicate returns `True`\n        - [nil][iterum.nil] if the predicate returns `False`\n    Examples:\n        &gt;&gt;&gt; assert nil.filter(lambda x: x % 2 == 0) == nil\n        &gt;&gt;&gt; assert Some(3).filter(lambda x: x % 2 == 0) == nil\n        &gt;&gt;&gt; assert Some(4).filter(lambda x: x % 2 == 0) == Some(4)\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.flatten","title":"<code>flatten() -&gt; Nil</code>","text":"<p>Converts from <code>Option[Option[T]]</code> to <code>Option[T]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n&gt;&gt;&gt; assert Some(nil).flatten() == nil\n&gt;&gt;&gt; assert nil.flatten() == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def flatten(self) -&gt; Nil:\n\"\"\"\n    Converts from `Option[Option[T]]` to `Option[T]`.\n    Examples:\n        &gt;&gt;&gt; assert Some(Some(6)).flatten() == Some(6)\n        &gt;&gt;&gt; assert Some(nil).flatten() == nil\n        &gt;&gt;&gt; assert nil.flatten() == nil\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.get_or_insert","title":"<code>get_or_insert(value: T) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts value into the option if it is nil, then returns a tuple of the resulting option and the returned value.</p> <p>See also insert, which updates the value even if the option already contains a value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n&gt;&gt;&gt; assert value == 5\n&gt;&gt;&gt; assert opt == Some(5)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n&gt;&gt;&gt; assert value == 3\n&gt;&gt;&gt; assert opt == Some(3)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n&gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n</code></pre> <pre><code>&gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n&gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def get_or_insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"\n    Inserts value into the option if it is [nil][iterum.nil], then returns a\n    tuple of the resulting option and the returned value.\n    See also [insert][iterum.Nil.insert], which updates the value even if\n    the option already contains a value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n        &gt;&gt;&gt; assert value == 5\n        &gt;&gt;&gt; assert opt == Some(5)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.get_or_insert(5)\n        &gt;&gt;&gt; assert value == 3\n        &gt;&gt;&gt; assert opt == Some(3)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; assert Some(10).get_or_insert(5).returned == 10\n        &gt;&gt;&gt; assert nil.get_or_insert(5).returned == 5\n        &gt;&gt;&gt; assert Some(10).get_or_insert(5).inserted == Some(10)\n        &gt;&gt;&gt; assert nil.get_or_insert(5).inserted == Some(5)\n    \"\"\"\nreturn Swap(Some(value), value)\n</code></pre>"},{"location":"api/#iterum._option.Nil.get_or_insert_with","title":"<code>get_or_insert_with(f: Callable[[], T]) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts a value computed from <code>f</code> into the option if it is nil, then returns a tuple of the resulting option and the returned value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert value == 5\n&gt;&gt;&gt; assert opt == Some(5)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert value == 3\n&gt;&gt;&gt; assert opt == Some(3)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert swap.inserted == Some(10)\n&gt;&gt;&gt; assert swap.returned == 10\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def get_or_insert_with(self, f: Callable[[], T], /) -&gt; Swap[Some[T], T]:\n\"\"\"\n    Inserts a value computed from `f` into the option if it is\n    [nil][iterum.nil], then returns a tuple of the resulting option and the\n    returned value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert value == 5\n        &gt;&gt;&gt; assert opt == Some(5)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert value == 3\n        &gt;&gt;&gt; assert opt == Some(3)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert swap.inserted == Some(10)\n        &gt;&gt;&gt; assert swap.returned == 10\n        &gt;&gt;&gt; swap = nil.get_or_insert_with(lambda: 5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n    \"\"\"\nreturn Swap(Some(value := f()), value)\n</code></pre>"},{"location":"api/#iterum._option.Nil.insert","title":"<code>insert(value: T) -&gt; Swap[Some[T], T]</code>","text":"<p>Inserts value into the option, then returns a tuple of the resulting option and the returned value.</p> <p>If the option already contains a value, the old value is dropped.</p> <p>See also get_or_insert, which doesn\u2019t update the value if the option already contains a value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opt = nil\n&gt;&gt;&gt; opt, value = opt.insert(1)\n&gt;&gt;&gt; assert value == 1\n&gt;&gt;&gt; assert opt == Some(1)\n</code></pre> <pre><code>&gt;&gt;&gt; opt = Some(3)\n&gt;&gt;&gt; opt, value = opt.insert(1)\n&gt;&gt;&gt; assert value == 1\n&gt;&gt;&gt; assert opt == Some(1)\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).insert(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.insert(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == 5\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def insert(self, value: T, /) -&gt; Swap[Some[T], T]:\n\"\"\"\n    Inserts value into the option, then returns a tuple of the resulting\n    option and the returned value.\n    If the option already contains a value, the old value is dropped.\n    See also [get_or_insert][iterum.Nil.get_or_insert], which doesn\u2019t\n    update the value if the option already contains a value.\n    Examples:\n        &gt;&gt;&gt; opt = nil\n        &gt;&gt;&gt; opt, value = opt.insert(1)\n        &gt;&gt;&gt; assert value == 1\n        &gt;&gt;&gt; assert opt == Some(1)\n        &gt;&gt;&gt; opt = Some(3)\n        &gt;&gt;&gt; opt, value = opt.insert(1)\n        &gt;&gt;&gt; assert value == 1\n        &gt;&gt;&gt; assert opt == Some(1)\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).insert(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n        &gt;&gt;&gt; swap = nil.insert(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == 5\n    \"\"\"\nreturn Swap(Some(value), value)\n</code></pre>"},{"location":"api/#iterum._option.Nil.is_nil","title":"<code>is_nil() -&gt; Literal[True]</code>","text":"<p>Returns <code>True</code> if the option is a nil value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_nil() is False\n&gt;&gt;&gt; assert nil.is_nil() is True\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_nil(self) -&gt; Literal[True]:\n\"\"\"\n    Returns `True` if the option is a [nil][iterum.nil] value.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_nil() is False\n        &gt;&gt;&gt; assert nil.is_nil() is True\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"api/#iterum._option.Nil.is_some","title":"<code>is_some() -&gt; Literal[False]</code>","text":"<p>Returns <code>True</code> if the option is a Some value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_some() is True\n&gt;&gt;&gt; assert nil.is_some() is False\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_some(self) -&gt; Literal[False]:\n\"\"\"\n    Returns `True` if the option is a Some value.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_some() is True\n        &gt;&gt;&gt; assert nil.is_some() is False\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"api/#iterum._option.Nil.is_some_and","title":"<code>is_some_and(f: Callable[[Any], object]) -&gt; Literal[False]</code>","text":"<p>Returns <code>True</code> if the option is a Some and the value inside of it matches a predicate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n&gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n&gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def is_some_and(self, f: Callable[[Any], object]) -&gt; Literal[False]:\n\"\"\"\n    Returns `True` if the option is a [Some][iterum.Some] and the value\n    inside of it matches a predicate.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).is_some_and(lambda x: x &gt; 1) is True\n        &gt;&gt;&gt; assert Some(0).is_some_and(lambda x: x &gt; 1) is False\n        &gt;&gt;&gt; assert nil.is_some_and(lambda x: x &gt; 1) is False\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"api/#iterum._option.Nil.iter","title":"<code>iter() -&gt; iterum[Any]</code>","text":"<p>Returns an iterator over the possibly contained value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n&gt;&gt;&gt; assert nil.iter().next() == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def iter(self) -&gt; iterum[Any]:\n\"\"\"\n    Returns an iterator over the possibly contained value.\n    Examples:\n        &gt;&gt;&gt; assert Some(4).iter().next() == Some(4)\n        &gt;&gt;&gt; assert nil.iter().next() == nil\n    \"\"\"\nfrom ._iterum import iterum\nreturn iterum([])\n</code></pre>"},{"location":"api/#iterum._option.Nil.map","title":"<code>map(f: Callable[[Any], Any]) -&gt; Nil</code>","text":"<p>Maps an Option[T] to Option[U] by applying a function to a contained value (if Some) or returns nil (if Nil).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n&gt;&gt;&gt; assert nil.map(len) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map(self, f: Callable[[Any], Any], /) -&gt; Nil:\n\"\"\"\n    Maps an [Option[T]][iterum.Option] to [Option[U]][iterum.Option] by\n    applying a function to a contained value (if [Some][iterum.Some]) or\n    returns [nil][iterum.nil] (if [Nil][iterum.Nil]).\n    Examples:\n        &gt;&gt;&gt; assert Some(\"Hello, World!\").map(len) == Some(13)\n        &gt;&gt;&gt; assert nil.map(len) == nil\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum._option.Nil.map_or","title":"<code>map_or(default: U, f: Callable[[Any], U]) -&gt; U</code>","text":"<p>Returns the provided default result (if nil), or applies a function to the contained value (if any).</p> <p>Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use map_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n&gt;&gt;&gt; assert nil.map_or(42, len) == 42\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map_or(self, default: U, f: Callable[[Any], U], /) -&gt; U:\n\"\"\"\n    Returns the provided default result (if [nil][iterum.nil]), or applies a\n    function to the contained value (if any).\n    Arguments passed to [map_or][iterum.Nil.map_or] are eagerly evaluated;\n    if you are passing the result of a function call, it is recommended to\n    use [map_or_else][iterum.Nil.map_or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").map_or(42, len) == 3\n        &gt;&gt;&gt; assert nil.map_or(42, len) == 42\n    \"\"\"\nreturn default\n</code></pre>"},{"location":"api/#iterum._option.Nil.map_or_else","title":"<code>map_or_else(default: Callable[[], U], f: Callable[[Any], U]) -&gt; U</code>","text":"<p>Computes a default function result (if nil), or applies a different function to the contained value (if any).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; k = 21\n&gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n&gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def map_or_else(self, default: Callable[[], U], f: Callable[[Any], U], /) -&gt; U:\n\"\"\"\n    Computes a default function result (if [nil][iterum.nil]), or applies a\n    different function to the contained value (if any).\n    Examples:\n        &gt;&gt;&gt; k = 21\n        &gt;&gt;&gt; assert Some(\"foo\").map_or_else(lambda: 2 * k, len) == 3\n        &gt;&gt;&gt; assert nil.map_or_else(lambda: 2 * k, len) == 42\n    \"\"\"\nreturn default()\n</code></pre>"},{"location":"api/#iterum._option.Nil.ok_or","title":"<code>ok_or(err: Exception) -&gt; NoReturn</code>","text":"<p>Unwraps the option returning the value if Some or raises the provided exception if nil.</p> <p>Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.ok_or(RuntimeError(\"oh no!\"))\n... except RuntimeError as ex:\n...     print(ex)\n...\noh no!\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def ok_or(self, err: Exception, /) -&gt; NoReturn:\n\"\"\"\n    Unwraps the option returning the value if [Some][iterum.Some] or raises\n    the provided exception if [nil][iterum.nil].\n    Arguments passed to [ok_or][iterum.Nil.ok_or] are eagerly evaluated; if\n    you are passing the result of a function call, it is recommended to use\n    [ok_or_else][iterum.Nil.ok_or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").ok_or(RuntimeError(\"oh no!\")) == \"foo\"\n        &gt;&gt;&gt; try:\n        ...     nil.ok_or(RuntimeError(\"oh no!\"))\n        ... except RuntimeError as ex:\n        ...     print(ex)\n        ...\n        oh no!\n    \"\"\"\nraise err\n</code></pre>"},{"location":"api/#iterum._option.Nil.ok_or_else","title":"<code>ok_or_else(err: Callable[[], Exception]) -&gt; NoReturn</code>","text":"<p>Unwraps the option returning the value if Some or raises the exception returned by the provided callable if nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n... except AssertionError as ex:\n...     print(ex)\n...\noopsy!\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def ok_or_else(self, err: Callable[[], Exception], /) -&gt; NoReturn:\n\"\"\"\n    Unwraps the option returning the value if [Some][iterum.Some] or raises\n    the exception returned by the provided callable if [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; assert Some(\"foo\").ok_or_else(AssertionError) == \"foo\"\n        &gt;&gt;&gt; try:\n        ...     nil.ok_or_else(lambda: AssertionError(\"oopsy!\"))\n        ... except AssertionError as ex:\n        ...     print(ex)\n        ...\n        oopsy!\n    \"\"\"\nraise err()\n</code></pre>"},{"location":"api/#iterum._option.Nil.or_","title":"<code>or_(optb: O) -&gt; O</code>","text":"<p>Returns the option if it contains a value, otherwise returns optb.</p> <p>Arguments passed to or_ are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n&gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n&gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n&gt;&gt;&gt; assert nil.or_(nil) == nil\n</code></pre> <p>Note: because <code>or</code> is a keyword, this method is called <code>or_</code> instead.</p> Source code in <code>iterum/_option.py</code> <pre><code>def or_(self, optb: O, /) -&gt; O:\n\"\"\"\n    Returns the option if it contains a value, otherwise returns optb.\n    Arguments passed to [or_][iterum.Nil.or_] are eagerly evaluated; if you\n    are passing the result of a function call, it is recommended to use\n    [or_else][iterum.Nil.or_else], which is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(2).or_(nil) == Some(2)\n        &gt;&gt;&gt; assert nil.or_(Some(100)) == Some(100)\n        &gt;&gt;&gt; assert Some(2).or_(Some(100)) == Some(2)\n        &gt;&gt;&gt; assert nil.or_(nil) == nil\n    Note: because `or` is a keyword, this method is called `or_` instead.\n    \"\"\"\n# 'or' is a keyword, so instead we use 'or_'\nreturn optb\n</code></pre>"},{"location":"api/#iterum._option.Nil.or_else","title":"<code>or_else(f: Callable[[], O]) -&gt; O</code>","text":"<p>Returns the option if it contains a value, otherwise calls <code>f</code> and returns the result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def nobody() -&gt; Option[str]:\n...     return nil\n...\n&gt;&gt;&gt; def vikings() -&gt; Option[str]:\n...     return Some(\"vikings\")\n...\n&gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n&gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n&gt;&gt;&gt; assert nil.or_else(nobody) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def or_else(self, f: Callable[[], O], /) -&gt; O:\n\"\"\"\n    Returns the option if it contains a value, otherwise calls `f` and\n    returns the result.\n    Examples:\n        &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n        ...     return nil\n        ...\n        &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n        ...     return Some(\"vikings\")\n        ...\n        &gt;&gt;&gt; assert Some(\"barbarians\").or_else(vikings) == Some(\"barbarians\")\n        &gt;&gt;&gt; assert nil.or_else(vikings) == Some(\"vikings\")\n        &gt;&gt;&gt; assert nil.or_else(nobody) == nil\n    \"\"\"\nreturn f()\n</code></pre>"},{"location":"api/#iterum._option.Nil.replace","title":"<code>replace(value: T) -&gt; Swap[Some[T], Nil]</code>","text":"<p>Replaces the actual value in the option by the value given in parameter, returning a tuple of the resulting option and the returned old value if present.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(2)\n&gt;&gt;&gt; new, old = x.replace(5)\n&gt;&gt;&gt; assert new == Some(5)\n&gt;&gt;&gt; assert old == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; x = nil\n&gt;&gt;&gt; new, old = x.replace(5)\n&gt;&gt;&gt; assert new == Some(5)\n&gt;&gt;&gt; assert old == nil\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(10).replace(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == Some(10)\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.replace(5)\n&gt;&gt;&gt; assert swap.inserted == Some(5)\n&gt;&gt;&gt; assert swap.returned == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def replace(self, value: T, /) -&gt; Swap[Some[T], Nil]:\n\"\"\"\n    Replaces the actual value in the option by the value given in parameter,\n    returning a tuple of the resulting option and the returned old value if\n    present.\n    Examples:\n        &gt;&gt;&gt; x = Some(2)\n        &gt;&gt;&gt; new, old = x.replace(5)\n        &gt;&gt;&gt; assert new == Some(5)\n        &gt;&gt;&gt; assert old == Some(2)\n        &gt;&gt;&gt; x = nil\n        &gt;&gt;&gt; new, old = x.replace(5)\n        &gt;&gt;&gt; assert new == Some(5)\n        &gt;&gt;&gt; assert old == nil\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(10).replace(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == Some(10)\n        &gt;&gt;&gt; swap = nil.replace(5)\n        &gt;&gt;&gt; assert swap.inserted == Some(5)\n        &gt;&gt;&gt; assert swap.returned == nil\n    \"\"\"\nreturn Swap(Some(value), nil)\n</code></pre>"},{"location":"api/#iterum._option.Nil.take","title":"<code>take() -&gt; Swap[Nil, Nil]</code>","text":"<p>Takes the value out of the option, returning a tuple of the resulting nil and the old option.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Some(2)\n&gt;&gt;&gt; new, old = x.take()\n&gt;&gt;&gt; assert new == nil\n&gt;&gt;&gt; assert old == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; x = nil\n&gt;&gt;&gt; new, old = x.take()\n&gt;&gt;&gt; assert new == nil\n&gt;&gt;&gt; assert old == nil\n</code></pre> <p>Alternatively, access the named attributes of Swap, inserted and returned:</p> <pre><code>&gt;&gt;&gt; swap = Some(2).take()\n&gt;&gt;&gt; assert swap.inserted == nil\n&gt;&gt;&gt; assert swap.returned == Some(2)\n</code></pre> <pre><code>&gt;&gt;&gt; swap = nil.take()\n&gt;&gt;&gt; assert swap.inserted == nil\n&gt;&gt;&gt; assert swap.returned == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def take(self) -&gt; Swap[Nil, Nil]:\n\"\"\"\n    Takes the value out of the option, returning a tuple of the resulting\n    nil and the old option.\n    Examples:\n        &gt;&gt;&gt; x = Some(2)\n        &gt;&gt;&gt; new, old = x.take()\n        &gt;&gt;&gt; assert new == nil\n        &gt;&gt;&gt; assert old == Some(2)\n        &gt;&gt;&gt; x = nil\n        &gt;&gt;&gt; new, old = x.take()\n        &gt;&gt;&gt; assert new == nil\n        &gt;&gt;&gt; assert old == nil\n        Alternatively, access the named attributes of [Swap][iterum.Swap],\n        [inserted][iterum.Swap.inserted] and [returned][iterum.Swap.returned]:\n        &gt;&gt;&gt; swap = Some(2).take()\n        &gt;&gt;&gt; assert swap.inserted == nil\n        &gt;&gt;&gt; assert swap.returned == Some(2)\n        &gt;&gt;&gt; swap = nil.take()\n        &gt;&gt;&gt; assert swap.inserted == nil\n        &gt;&gt;&gt; assert swap.returned == nil\n    \"\"\"\nreturn Swap(nil, self)\n</code></pre>"},{"location":"api/#iterum._option.Nil.unwrap","title":"<code>unwrap() -&gt; NoReturn</code>","text":"<p>Returns the contained Some value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n</code></pre> <pre><code>&gt;&gt;&gt; try:\n...     nil.unwrap()\n... except UnwrapNilError as ex:\n...     print(\"Attempted to unwrap a nil!\")\n...\nAttempted to unwrap a nil!\n</code></pre> <p>Raises:</p> Type Description <code>UnwrapNilError</code> <p>if the value is a nil.</p> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap(self) -&gt; NoReturn:\n\"\"\"\n    Returns the contained [Some][iterum.Some] value.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"air\").unwrap() == \"air\"\n        &gt;&gt;&gt; try:\n        ...     nil.unwrap()\n        ... except UnwrapNilError as ex:\n        ...     print(\"Attempted to unwrap a nil!\")\n        ...\n        Attempted to unwrap a nil!\n    Raises:\n        UnwrapNilError: if the value is a [nil][iterum.nil].\n    \"\"\"\nraise UnwrapNilError()\n</code></pre>"},{"location":"api/#iterum._option.Nil.unwrap_or","title":"<code>unwrap_or(default: T) -&gt; T</code>","text":"<p>Returns the contained Some value or a provided default.</p> <p>Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else, which is lazily evaluated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n&gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap_or(self, default: T, /) -&gt; T:\n\"\"\"\n    Returns the contained [Some][iterum.Some] value or a provided default.\n    Arguments passed to [unwrap_or][iterum.Nil.unwrap_or] are eagerly\n    evaluated; if you are passing the result of a function call, it is\n    recommended to use [unwrap_or_else][iterum.Nil.unwrap_or_else], which\n    is lazily evaluated.\n    Examples:\n        &gt;&gt;&gt; assert Some(\"car\").unwrap_or(\"bike\") == \"car\"\n        &gt;&gt;&gt; assert nil.unwrap_or(\"bike\") == \"bike\"\n    \"\"\"\nreturn default\n</code></pre>"},{"location":"api/#iterum._option.Nil.unwrap_or_else","title":"<code>unwrap_or_else(f: Callable[[], T]) -&gt; T</code>","text":"<p>Returns the contained Some value or computes it from a closure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; k = 10\n&gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n&gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unwrap_or_else(self, f: Callable[[], T], /) -&gt; T:\n\"\"\"\n    Returns the contained [Some][iterum.Some] value or computes it from a closure.\n    Examples:\n        &gt;&gt;&gt; k = 10\n        &gt;&gt;&gt; assert Some(4).unwrap_or_else(lambda: 2 * k) == 4\n        &gt;&gt;&gt; assert nil.unwrap_or_else(lambda: 2 * k) == 20\n    \"\"\"\nreturn f()\n</code></pre>"},{"location":"api/#iterum._option.Nil.unzip","title":"<code>unzip() -&gt; tuple[Nil, Nil]</code>","text":"<p>Unzips an option containing a tuple of two options.</p> <p>If <code>self</code> is <code>Some((a, b))</code> this method returns <code>(Some(a), Some(b))</code>. Otherwise, <code>(nil, nil)</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n&gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def unzip(self) -&gt; tuple[Nil, Nil]:\n\"\"\"\n    Unzips an option containing a tuple of two options.\n    If `self` is `Some((a, b))` this method returns `(Some(a), Some(b))`.\n    Otherwise, `(nil, nil)` is returned.\n    Examples:\n        &gt;&gt;&gt; assert Some((1, \"hi\")).unzip() == (Some(1), Some(\"hi\"))\n        &gt;&gt;&gt; assert nil.unzip() == (nil, nil)\n    \"\"\"\nreturn (nil, nil)\n</code></pre>"},{"location":"api/#iterum._option.Nil.xor","title":"<code>xor(optb: O) -&gt; O | Nil</code>","text":"<p>Returns Some if exactly one of <code>self</code>, <code>optb</code> is Some, otherwise returns nil.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n&gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n&gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n&gt;&gt;&gt; assert nil.xor(nil) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def xor(self, optb: O, /) -&gt; O | Nil:\n\"\"\"\n    Returns [Some][iterum.Some] if exactly one of `self`, `optb` is\n    [Some][iterum.Some], otherwise returns [nil][iterum.nil].\n    Examples:\n        &gt;&gt;&gt; assert Some(2).xor(nil) == Some(2)\n        &gt;&gt;&gt; assert nil.xor(Some(100)) == Some(100)\n        &gt;&gt;&gt; assert Some(2).xor(Some(100)) == nil\n        &gt;&gt;&gt; assert nil.xor(nil) == nil\n    \"\"\"\nreturn nil if isinstance(optb, Nil) else optb\n</code></pre>"},{"location":"api/#iterum._option.Nil.zip","title":"<code>zip(other: Option[U]) -&gt; Nil</code>","text":"<p>Zips <code>self</code> with another option.</p> <p>If <code>self</code> is <code>Some(s)</code> and <code>other</code> is <code>Some(o)</code>, this method returns <code>Some((s, o))</code>. Otherwise, nil is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n&gt;&gt;&gt; assert Some(1).zip(nil) == nil\n&gt;&gt;&gt; assert nil.zip(nil) == nil\n</code></pre> Source code in <code>iterum/_option.py</code> <pre><code>def zip(self, other: Option[U], /) -&gt; Nil:\n\"\"\"\n    Zips `self` with another option.\n    If `self` is `Some(s)` and `other` is `Some(o)`,\n    this method returns `Some((s, o))`.\n    Otherwise, [nil][iterum.nil] is returned.\n    Examples:\n        &gt;&gt;&gt; assert Some(1).zip(Some(\"hi\")) == Some((1, \"hi\"))\n        &gt;&gt;&gt; assert Some(1).zip(nil) == nil\n        &gt;&gt;&gt; assert nil.zip(nil) == nil\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"api/#iterum.nil","title":"<code>iterum.nil = Nil()</code>  <code>module-attribute</code>","text":"<p>Instance of type Nil. See Nil for more details.</p>"},{"location":"api/#iterum.ExpectNilError","title":"<code>iterum.ExpectNilError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>Exception raised when nil.expect is called.</p> Source code in <code>iterum/_option.py</code> <pre><code>class ExpectNilError(RuntimeError):\n\"\"\"\n    Exception raised when [nil.expect][iterum.Nil.expect] is called.\n    \"\"\"\ndef __init__(self, msg: str = \"Expected some but option is nil\") -&gt; None:\nsuper().__init__(msg)\n</code></pre>"},{"location":"api/#iterum.UnwrapNilError","title":"<code>iterum.UnwrapNilError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>Exception raised when nil.unwrap is called.</p> Source code in <code>iterum/_option.py</code> <pre><code>class UnwrapNilError(RuntimeError):\n\"\"\"\n    Exception raised when [nil.unwrap][iterum.Nil.unwrap] is called.\n    \"\"\"\ndef __init__(self, msg: str = \"Attempted to unwrap nil\") -&gt; None:\nsuper().__init__(msg)\n</code></pre>"},{"location":"api/#iterum.State","title":"<code>iterum.State</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Simple class which holds some mutable state.</p> Source code in <code>iterum/_iterum.py</code> <pre><code>@dataclass\nclass State(Generic[T]):\n\"\"\"\n    Simple class which holds some mutable state.\n    \"\"\"\nvalue: T\n\"\"\"\n    current value of the state\n    \"\"\"\n</code></pre>"},{"location":"api/#iterum._iterum.State.value","title":"<code>value: T</code>  <code>instance-attribute</code>","text":"<p>current value of the state</p>"},{"location":"api/#iterum.Swap","title":"<code>iterum.Swap</code>","text":"<p>         Bases: <code>NamedTuple</code>, <code>Generic[T, U]</code></p> <p>Used for various 'swapping' operations on Option.</p> Source code in <code>iterum/_option.py</code> <pre><code>class Swap(NamedTuple, Generic[T, U]):\n\"\"\"\n    Used for various 'swapping' operations on [Option][iterum.Option].\n    \"\"\"\ninserted: T\n\"\"\"\n    Value inserted into an option\n    \"\"\"\nreturned: U\n\"\"\"\n    Value returned from an option\n    \"\"\"\n</code></pre>"},{"location":"api/#iterum._option.Swap.inserted","title":"<code>inserted: T</code>  <code>instance-attribute</code>","text":"<p>Value inserted into an option</p>"},{"location":"api/#iterum._option.Swap.returned","title":"<code>returned: U</code>  <code>instance-attribute</code>","text":"<p>Value returned from an option</p>"},{"location":"api/#iterum.Ordering","title":"<code>iterum.Ordering</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An Ordering is the result of a comparison between two values.</p> Source code in <code>iterum/_ordering.py</code> <pre><code>@unique\nclass Ordering(Enum):\n\"\"\"\n    An [Ordering][iterum.Ordering] is the result of a comparison between\n    two values.\n    \"\"\"\nLess = create_singleton(\"Less\")\n\"\"\"\n    An ordering where a compared value is less than another.\n    \"\"\"\nEqual = create_singleton(\"Equal\")\n\"\"\"\n    An ordering where a compared value is equal to another.\n    \"\"\"\nGreater = create_singleton(\"Greater\")\n\"\"\"\n    An ordering where a compared value is greater than another.\n    \"\"\"\n@staticmethod\ndef cmp(lhs, rhs, /) -&gt; Ordering:\n\"\"\"\n        Compare two values.\n        Examples:\n            &gt;&gt;&gt; Ordering.cmp(1, 2)\n            Ordering.Less\n            &gt;&gt;&gt; Ordering.cmp(1, 1)\n            Ordering.Equal\n            &gt;&gt;&gt; Ordering.cmp(2, 1)\n            Ordering.Greater\n            A `TypeError` will be raised if the two objects are not comparable:\n            &gt;&gt;&gt; try:\n            ...     Ordering.cmp(1, \"two\")\n            ... except TypeError as ex:\n            ...     print(f\"exception received: {ex}\")\n            ...\n            exception received: '&gt;' not supported between instances of 'int' and 'str'\n        \"\"\"\nif lhs == rhs:\nreturn Ordering.Equal\nif lhs &gt; rhs:\nreturn Ordering.Greater\nif lhs &lt; rhs:\nreturn Ordering.Less\nraise ValueError(f\"Unable to compare {lhs!r} with {rhs!r}\")\ndef __repr__(self) -&gt; str:\nreturn f\"{type(self).__name__}.{self.name}\"\n</code></pre>"},{"location":"api/#iterum._ordering.Ordering.Less","title":"<code>Less = create_singleton('Less')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An ordering where a compared value is less than another.</p>"},{"location":"api/#iterum._ordering.Ordering.Equal","title":"<code>Equal = create_singleton('Equal')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An ordering where a compared value is equal to another.</p>"},{"location":"api/#iterum._ordering.Ordering.Greater","title":"<code>Greater = create_singleton('Greater')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An ordering where a compared value is greater than another.</p>"},{"location":"api/#iterum._ordering.Ordering.cmp","title":"<code>cmp(lhs, rhs) -&gt; Ordering</code>  <code>staticmethod</code>","text":"<p>Compare two values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Ordering.cmp(1, 2)\nOrdering.Less\n&gt;&gt;&gt; Ordering.cmp(1, 1)\nOrdering.Equal\n&gt;&gt;&gt; Ordering.cmp(2, 1)\nOrdering.Greater\n</code></pre> <p>A <code>TypeError</code> will be raised if the two objects are not comparable:</p> <pre><code>&gt;&gt;&gt; try:\n...     Ordering.cmp(1, \"two\")\n... except TypeError as ex:\n...     print(f\"exception received: {ex}\")\n...\nexception received: '&gt;' not supported between instances of 'int' and 'str'\n</code></pre> Source code in <code>iterum/_ordering.py</code> <pre><code>@staticmethod\ndef cmp(lhs, rhs, /) -&gt; Ordering:\n\"\"\"\n    Compare two values.\n    Examples:\n        &gt;&gt;&gt; Ordering.cmp(1, 2)\n        Ordering.Less\n        &gt;&gt;&gt; Ordering.cmp(1, 1)\n        Ordering.Equal\n        &gt;&gt;&gt; Ordering.cmp(2, 1)\n        Ordering.Greater\n        A `TypeError` will be raised if the two objects are not comparable:\n        &gt;&gt;&gt; try:\n        ...     Ordering.cmp(1, \"two\")\n        ... except TypeError as ex:\n        ...     print(f\"exception received: {ex}\")\n        ...\n        exception received: '&gt;' not supported between instances of 'int' and 'str'\n    \"\"\"\nif lhs == rhs:\nreturn Ordering.Equal\nif lhs &gt; rhs:\nreturn Ordering.Greater\nif lhs &lt; rhs:\nreturn Ordering.Less\nraise ValueError(f\"Unable to compare {lhs!r} with {rhs!r}\")\n</code></pre>"},{"location":"api/#iterum.Chain","title":"<code>iterum.Chain</code>","text":"<p>         Bases: <code>_IterumAdapter[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Chain(_IterumAdapter[T_co]):\n__slots__ = (\"_iter\",)\ndef __init__(self, *__iterables: Iterable[T_co]) -&gt; None:\nself._iter = itertools.chain(*__iterables)\n</code></pre>"},{"location":"api/#iterum.Cycle","title":"<code>iterum.Cycle</code>","text":"<p>         Bases: <code>_IterumAdapter[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Cycle(_IterumAdapter[T_co]):\n__slots__ = (\"_iter\",)\ndef __init__(self, __iterable: Iterable[T_co]) -&gt; None:\nself._iter = itertools.cycle(__iterable)\n</code></pre>"},{"location":"api/#iterum.Enumerate","title":"<code>iterum.Enumerate</code>","text":"<p>         Bases: <code>_IterumAdapter[tuple[int, T_co]]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Enumerate(_IterumAdapter[tuple[int, T_co]]):\n__slots__ = (\"_iter\",)\ndef __init__(self, __iterable: Iterable[T_co], /) -&gt; None:\nself._iter = builtins.enumerate(__iterable)\n</code></pre>"},{"location":"api/#iterum.Filter","title":"<code>iterum.Filter</code>","text":"<p>         Bases: <code>_IterumAdapter[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Filter(_IterumAdapter[T_co]):\n__slots__ = (\"_iter\",)\ndef __init__(\nself, __iterable: Iterable[T_co], predicate: Callable[[T_co], object], /\n) -&gt; None:\nself._iter = builtins.filter(predicate, __iterable)\n</code></pre>"},{"location":"api/#iterum.FlatMap","title":"<code>iterum.FlatMap</code>","text":"<p>         Bases: <code>_IterumAdapter[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class FlatMap(_IterumAdapter[T_co]):\n__slots__ = (\"_iter\",)\ndef __init__(\nself, __iterable: Iterable[U], f: Callable[[U], Iterable[T_co]], /\n) -&gt; None:\nself._iter = iterum(__iterable).map(f).flatten()\n</code></pre>"},{"location":"api/#iterum.FilterMap","title":"<code>iterum.FilterMap</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class FilterMap(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_predicate\")\ndef __init__(\nself, __iterable: Iterable[U], predicate: Callable[[U], Option[T_co]], /\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._predicate = predicate\ndef next(self) -&gt; Option[T_co]:\nwhile True:\nx = self._iter.next()\nif x.is_nil():\nreturn nil\nr = self._predicate(x.unwrap())\nif r.is_some():\nreturn r\n</code></pre>"},{"location":"api/#iterum.Flatten","title":"<code>iterum.Flatten</code>","text":"<p>         Bases: <code>_IterumAdapter[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Flatten(_IterumAdapter[T_co]):\n__slots__ = (\"_iter\",)\ndef __init__(self, __iterable: Iterable[Iterable[T_co]], /) -&gt; None:\nself._iter = iter(y for x in __iterable for y in x)\n</code></pre>"},{"location":"api/#iterum.Fuse","title":"<code>iterum.Fuse</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Fuse(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_fuse\")\ndef __init__(self, __iterable: Iterable[T_co]) -&gt; None:\nself._iter = iterum(__iterable)\nself._fuse = True\ndef next(self) -&gt; Option[T_co]:\nif not self._fuse:\nreturn nil\nnxt = self._iter.next()\nif nxt.is_nil():\nself._fuse = False\nreturn nil\nreturn nxt\n</code></pre>"},{"location":"api/#iterum.Inspect","title":"<code>iterum.Inspect</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Inspect(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_f\")\ndef __init__(\nself, __iterable: Iterable[T_co], f: Callable[[T_co], object], /\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._f = f\ndef next(self) -&gt; Option[T_co]:\nnxt = self._iter.next()\nnxt.map(self._f)\nreturn nxt\n</code></pre>"},{"location":"api/#iterum.Map","title":"<code>iterum.Map</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Map(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_f\")\ndef __init__(self, __iterable: Iterable[U], f: Callable[[U], T_co], /) -&gt; None:\nself._iter = iterum(__iterable)\nself._f = f\ndef next(self) -&gt; Option[T_co]:\nreturn self._iter.next().map(self._f)\n</code></pre>"},{"location":"api/#iterum.MapWhile","title":"<code>iterum.MapWhile</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class MapWhile(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_predicate\", \"_fuse\")\ndef __init__(\nself, __iterable: Iterable[U], predicate: Callable[[U], Option[T_co]], /\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._predicate = predicate\nself._fuse = True\ndef next(self) -&gt; Option[T_co]:\nif not self._fuse:\nreturn nil\nr = self._iter.next().map(self._predicate).flatten()\nif r.is_nil():\nself._fuse = False\nreturn r\n</code></pre>"},{"location":"api/#iterum.Peekable","title":"<code>iterum.Peekable</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Peekable(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_peek\")\ndef __init__(self, __iterable: Iterable[T_co], /) -&gt; None:\nself._iter = iterum(__iterable)\nself._peek: Option[T_co] | NotSetType = NotSet\ndef next(self) -&gt; Option[T_co]:\nif isinstance(self._peek, NotSetType):\nreturn self._iter.next()\nelif self._peek is nil:\nreturn nil\nelse:\nnxt, self._peek = self._peek, NotSet\nreturn nxt\n@property\ndef peek(self) -&gt; Option[T_co]:\nif isinstance(self._peek, NotSetType):\nself._peek = self.next()\nreturn self._peek\n@peek.setter\ndef peek(self, value: T_co) -&gt; None:  # type: ignore | reason: still need to constrain input param type\nif self.peek.is_nil():\nraise IndexError(\"Cannot set peek value past end of the iterum\")\nself._peek = Some(value)\n</code></pre>"},{"location":"api/#iterum.Rev","title":"<code>iterum.Rev</code>","text":"<p>         Bases: <code>Diterum[T_co]</code></p> <p>Implements a Diterum interface that wraps a diterum object and swaps calls to next with next_back and vice versa.</p> Source code in <code>iterum/_diterum.py</code> <pre><code>class Rev(Diterum[T_co]):\n\"\"\"\n    Implements a [Diterum][iterum.Diterum] interface that wraps\n    a [diterum][iterum.diterum] object and swaps calls to\n    [next][iterum.Diterum.next_back] with [next_back][iterum.Iterum.next]\n    and vice versa.\n    \"\"\"\n__slots__ = (\"_x\",)\ndef __init__(self, __x: Diterum[T_co] | Sequence[T_co]) -&gt; None:\nself._x = __x if isinstance(__x, Diterum) else diterum(__x)\ndef next(self) -&gt; Option[T_co]:\nreturn self._x.next_back()\ndef next_back(self) -&gt; Option[T_co]:\nreturn self._x.next()\ndef len(self) -&gt; int:\nreturn self._x.len()\n</code></pre>"},{"location":"api/#iterum.Scan","title":"<code>iterum.Scan</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Scan(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_state\", \"_f\")\ndef __init__(\nself,\n__iterable: Iterable[U],\ninit: V,\nf: Callable[[State[V], U], Option[T_co]],\n/,\n):\nself._iter = iterum(__iterable)\nself._state = State(init)\nself._f = f\ndef next(self) -&gt; Option[T_co]:\nreturn self._iter.next().map(lambda val: self._f(self._state, val)).flatten()\n</code></pre>"},{"location":"api/#iterum.Skip","title":"<code>iterum.Skip</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Skip(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_n\")\ndef __init__(\nself,\n__iterable: Iterable[T_co],\nn: int,\n/,\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._n = n\ndef next(self) -&gt; Option[T_co]:\nif self._n:\nself._iter.nth(self._n - 1)\nself._n = 0\nreturn self._iter.next()\n</code></pre>"},{"location":"api/#iterum.SkipWhile","title":"<code>iterum.SkipWhile</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class SkipWhile(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_predicate\", \"_fuse\")\ndef __init__(\nself,\n__iterable: Iterable[T_co],\npredicate: Callable[[T_co], object],\n/,\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._predicate = predicate\nself._fuse = True\ndef next(self) -&gt; Option[T_co]:\nif not self._fuse:\nreturn self._iter.next()\nnxt = nil\nwhile self._fuse:\nnxt = self._iter.next()\nself._fuse = nxt.is_some_and(self._predicate)\nreturn nxt\n</code></pre>"},{"location":"api/#iterum.StepBy","title":"<code>iterum.StepBy</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class StepBy(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_step\")\ndef __init__(self, __iterable: Iterable[T_co], step: int, /) -&gt; None:\nif step &lt;= 0:\nraise ValueError(f\"Step must be positive, provided: {step}\")\nself._iter = iterum(__iterable).enumerate()\nself._step = step\ndef next(self) -&gt; Option[T_co]:\nidx, nxt = self._iter.next().unzip()\nwhile nxt.is_some() and idx.is_some_and(lambda idx: idx % self._step):\nidx, nxt = self._iter.next().unzip()\nreturn nxt\n</code></pre>"},{"location":"api/#iterum.Take","title":"<code>iterum.Take</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Take(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_max\", \"_idx\")\ndef __init__(self, __iterable: Iterable[T_co], n: int, /) -&gt; None:\nself._iter = iterum(__iterable)\nself._max = n\nself._idx = 0\ndef next(self) -&gt; Option[T_co]:\nif self._idx &gt;= self._max:\nreturn nil\nself._idx += 1\nreturn self._iter.next()\n</code></pre>"},{"location":"api/#iterum.TakeWhile","title":"<code>iterum.TakeWhile</code>","text":"<p>         Bases: <code>Iterum[T_co]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class TakeWhile(Iterum[T_co]):\n__slots__ = (\"_iter\", \"_predicate\")\ndef __init__(\nself, __iterable: Iterable[T_co], predicate: Callable[[T_co], object], /\n) -&gt; None:\nself._iter = iterum(__iterable)\nself._predicate = predicate\ndef next(self) -&gt; Option[T_co]:\nnxt = self._iter.next()\nif nxt.is_some_and(self._predicate):\nreturn nxt\nreturn nil\n</code></pre>"},{"location":"api/#iterum.Zip","title":"<code>iterum.Zip</code>","text":"<p>         Bases: <code>_IterumAdapter[tuple[U, V]]</code></p> Source code in <code>iterum/_iterum.py</code> <pre><code>class Zip(_IterumAdapter[tuple[U, V]]):\n__slots__ = (\"_iter\",)\ndef __init__(self, __iterable: Iterable[U], other: Iterable[V], /) -&gt; None:\nself._iter = zip(__iterable, other)\n</code></pre>"},{"location":"api/#iterum.Seq","title":"<code>iterum.Seq</code>","text":"<p>         Bases: <code>Diterum[int]</code></p> Source code in <code>iterum/_seq.py</code> <pre><code>class Seq(Diterum[int]):\n__slots__ = (\"_front\", \"_back\", \"_step\", \"_dir\")\ndef __init__(self, *, start: int, end: int, step: int) -&gt; None:\nself._front = start\nself._back = _compute_back(start, end, step)\nself._step = step\nself._dir = _sign(step)\ndef next(self) -&gt; Option[int]:\nif self._dir * (self._back - self._front) &lt; 0:\nreturn nil\nnxt = Some(self._front)\nself._front += self._step\nreturn nxt\ndef next_back(self) -&gt; Option[int]:\nif self._dir * (self._back - self._front) &lt; 0:\nreturn nil\nnxt_bk = Some(self._back)\nself._back -= self._step\nreturn nxt_bk\ndef len(self) -&gt; int:\nif self._dir * (self._back - self._front) &lt; 0:\nreturn 0\nreturn (self._back + self._step - self._front) // self._step\ndef __repr__(self) -&gt; str:\nreturn (\nf\"{type(self).__name__}(\"\nf\"start={self._front}\"\nf\", end={self._back + self._step}\"\nf\", step={self._step}\"\n\")\"\n)\ndef __bool__(self) -&gt; bool:\nreturn self.len() != 0\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, Seq):\nreturn NotImplemented\nreturn (\n(self._front == other._front)\nand (self._back == other._back)\nand (self._step == other._step)\n)\n</code></pre>"},{"location":"api/#iterum.InfSeq","title":"<code>iterum.InfSeq</code>","text":"<p>         Bases: <code>Iterum[int]</code></p> Source code in <code>iterum/_seq.py</code> <pre><code>class InfSeq(Iterum[int]):\n__slots__ = (\"_front\", \"_step\")\ndef __init__(self, *, start: int, step: int) -&gt; None:\nself._front = start\nself._step = step\ndef next(self) -&gt; Option[int]:\nnxt = Some(self._front)\nself._front += self._step\nreturn nxt\ndef __repr__(self) -&gt; str:\nreturn f\"{type(self).__name__}(start={self._front}, step={self._step})\"\ndef __bool__(self) -&gt; bool:\nreturn True\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, InfSeq):\nreturn NotImplemented\nreturn (self._front == other._front) and (self._step == other._step)\n</code></pre>"}]}